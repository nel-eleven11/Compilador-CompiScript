# Generated by Compiscript Compiler
# MIPS Assembly Code

# Generated by Compiscript Compiler
.data
var_log: .word 0  # Address: 0x1000
var_nombre: .word 0  # Address: 0x1008
var_color: .word 0  # Address: 0x1010
var_nelson: .word 0  # Address: 0x1018
# String literals
str_0: .asciiz ""
str_1: .asciiz "rojo"
str_2: .asciiz "Hola, mi nombre es "
str_3: .asciiz "Ahora tengo "
str_4: .asciiz " anios."
str_5: .asciiz "Nelson"
str_6: .asciiz "Verde"
# String concatenation buffer
string_concat_buffer: .space 256  # 256 byte buffer for string concat


.text
.globl main

j main

# Quadruple 0: (label, None, None, FUNC_toString)
FUNC_toString:

# Quadruple 1: (enter, 4, None, None)
    # Function prologue (locals: 4 bytes)
    sw $ra, -4($sp)
    sw $fp, -8($sp)
    move $fp, $sp
    addiu $sp, $sp, -12

# Quadruple 2: (=, str_0, None, t0)
    la $t0, str_0  # Load string address

# Quadruple 3: (return, t0, None, None)
    # Return statement
    move $v0, $t0

# Quadruple 4: (leave, None, None, None)
    # Function epilogue
    addiu $sp, $fp, -8
    lw $fp, 0($sp)
    lw $ra, 4($sp)
    addiu $sp, $sp, 8
    jr $ra

# Quadruple 5: (label, None, None, FUNC_constructor (Persona))
FUNC_constructor_Persona:

# Quadruple 6: (enter, 12, None, None)
    # Function prologue (locals: 12 bytes)
    sw $ra, -4($sp)
    sw $fp, -8($sp)
    move $fp, $sp
    addiu $sp, $sp, -20

# Quadruple 7: (=, 12, None, t0)
    li $t0, 12

# Quadruple 8: (@, FP[0], None, t1)  # Load __this pointer
    lw $t1, 0($fp)  # Load from frame

# Quadruple 9: (+, t1, 0, t2)  # Address of Persona.nombre
    # Address of Persona.nombre
    addiu $t2, $t1, 0

# Quadruple 10: ([], t2, None, t3)  # Load Persona.nombre
    lw $t3, 0($t2)  # Array load

# Quadruple 11: (+, t3, 8, t4)  # Address of Persona.edad
    # Address of Persona.edad
    addiu $t4, $t3, 8

# Quadruple 12: ([]=, t0, None, t4)  # Store Persona.edad
    sw $t0, 0($t4)  # Array store

# Quadruple 13: (=, str_1, None, t5)
    la $t5, str_1  # Load string address

# Quadruple 14: (+, t5, 12, t6)  # Address of Persona.color
    # Address of Persona.color
    addiu $t6, $t5, 12

# Quadruple 15: ([]=, t5, None, t6)  # Store Persona.color
    sw $t5, 0($t6)  # Array store

# Quadruple 16: (return, None, None, None)
    # Return statement

# Quadruple 17: (leave, None, None, None)
    # Function epilogue
    addiu $sp, $fp, -8
    lw $fp, 0($sp)
    lw $ra, 4($sp)
    addiu $sp, $sp, 8
    jr $ra

# Quadruple 18: (label, None, None, FUNC_saludar (Persona))
FUNC_saludar_Persona:

# Quadruple 19: (enter, 4, None, None)
    # Function prologue (locals: 4 bytes)
    sw $ra, -4($sp)
    sw $fp, -8($sp)
    move $fp, $sp
    addiu $sp, $sp, -12

# Quadruple 20: (=, str_2, None, t0)
    la $t0, str_2  # Load string address

# Quadruple 21: (@, FP[0], None, t1)  # Load __this pointer
    lw $t1, 0($fp)  # Load from frame

# Quadruple 22: (+, t1, 0, t2)  # Address of Persona.nombre
    # Address of Persona.nombre
    addiu $t2, $t1, 0

# Quadruple 23: ([], t2, None, t3)  # Load Persona.nombre
    lw $t3, 0($t2)  # Array load

# Quadruple 24: (+, t0, t3, t4)
    add $t4, $t0, $t3

# Quadruple 25: (return, t4, None, None)
    # Return statement
    move $v0, $t4

# Quadruple 26: (leave, None, None, None)
    # Function epilogue
    addiu $sp, $fp, -8
    lw $fp, 0($sp)
    lw $ra, 4($sp)
    addiu $sp, $sp, 8
    jr $ra

# Quadruple 27: (label, None, None, FUNC_incrementarEdad (Persona))
FUNC_incrementarEdad_Persona:

# Quadruple 28: (enter, 8, None, None)
    # Function prologue (locals: 8 bytes)
    sw $ra, -4($sp)
    sw $fp, -8($sp)
    move $fp, $sp
    addiu $sp, $sp, -16

# Quadruple 29: (@, FP[0], None, t0)  # Load __this pointer
    lw $t0, 0($fp)  # Load from frame

# Quadruple 30: (+, t0, 8, t1)  # Address of Persona.edad
    # Address of Persona.edad
    addiu $t1, $t0, 8

# Quadruple 31: ([], t1, None, t2)  # Load Persona.edad
    lw $t2, 0($t1)  # Array load

# Quadruple 32: (+, t2, FP[4], t3)
    lw $t7, 4($fp)  # Load from frame
    add $t3, $t2, $t7

# Quadruple 33: (+, t3, 8, t4)  # Address of Persona.edad
    # Address of Persona.edad
    addiu $t4, $t3, 8

# Quadruple 34: ([]=, t3, None, t4)  # Store Persona.edad
    sw $t3, 0($t4)  # Array store

# Quadruple 35: (=, str_3, None, t5)
    la $t5, str_3  # Load string address

# Quadruple 36: (@, FP[0], None, t6)  # Load __this pointer
    lw $t6, 0($fp)  # Load from frame

# Quadruple 37: (+, t6, 8, t7)  # Address of Persona.edad
    # Address of Persona.edad
    addiu $t7, $t6, 8

# Quadruple 38: ([], t7, None, t8)  # Load Persona.edad
    lw $t8, 0($t7)  # Array load

# Quadruple 39: (+, t5, t8, t9)
    add $t9, $t5, $t8

# Quadruple 40: (=, str_4, None, t10)
    la $s0, str_4  # Load string address

# Quadruple 41: (+, t9, t10, t11)
    add $s1, $t9, $s0

# Quadruple 42: (return, t11, None, None)
    # Return statement
    move $v0, $s1

# Quadruple 43: (leave, None, None, None)
    # Function epilogue
    addiu $sp, $fp, -8
    lw $fp, 0($sp)
    lw $ra, 4($sp)
    addiu $sp, $sp, 8
    jr $ra

main:
    # Main prologue
    addiu $sp, $sp, -4
    sw $ra, 0($sp)

    # Quadruple 44: (=, str_0, None, 0x1000)
    la $t9, str_0  # Load string address
    sw $t9, var_log

    # Quadruple 45: (=, str_5, None, 0x1008)
    la $t9, str_5  # Load string address
    sw $t9, var_nombre

    # Quadruple 46: (=, str_6, None, 0x1010)
    la $t9, str_6  # Load string address
    sw $t9, var_color

    # Quadruple 47: (=, 0x8000, None, t12)
    la $s2, 0x8000  # Load array address

    # Quadruple 48: (push, 22, None, None)
    # Push argument: 22
    li $t9, 22
    addiu $sp, $sp, -4
    sw $t9, 0($sp)

    # Quadruple 49: (push, 0x1008, None, None)
    # Push argument: 0x1008
    lw $t9, var_nombre
    addiu $sp, $sp, -4
    sw $t9, 0($sp)

    # Quadruple 50: (push, t12, None, None)  # Push __this (será FP[0])
    # Push argument: t12
    addiu $sp, $sp, -4
    sw $s2, 0($sp)

    # Quadruple 51: (call, None, None, FUNC_constructor (Persona))  # Call Persona.constructor
    # Call function: FUNC_constructor (Persona)
    jal FUNC_constructor_Persona

    # Quadruple 52: (add, SP, 12, SP)
    # Clean up arguments from stack (12 bytes)
    addiu $sp, $sp, 12

    # Quadruple 53: (pop, None, None, t13)
    # Get return value
    move $s3, $v0

    # Quadruple 54: (=, t12, None, 0x1018)
    sw $s2, var_nelson

    # Quadruple 55: (push, 0x1018, None, None)  # Push __this (será FP[0])
    # Push argument: 0x1018
    lw $t9, var_nelson
    addiu $sp, $sp, -4
    sw $t9, 0($sp)

    # Quadruple 56: (call, None, None, FUNC_saludar (Persona))  # Call Persona.saludar
    # Call function: FUNC_saludar (Persona)
    jal FUNC_saludar_Persona

    # Quadruple 57: (add, SP, 4, SP)
    # Clean up arguments from stack (4 bytes)
    addiu $sp, $sp, 4

    # Quadruple 58: (pop, None, None, t12)
    # Get return value
    move $s2, $v0

    # Quadruple 59: (print_str, t12, None, None)  # Print string
    move $a0, $s2
    li $v0, 4       # print_str
    syscall

    # Main epilogue
    lw $ra, 0($sp)
    addiu $sp, $sp, 4
    li $v0, 10  # Exit syscall
    syscall

# ===== String Runtime Functions =====

__string_copy:
    # Save registers
    addiu $sp, $sp, -8
    sw $t0, 0($sp)
    sw $t1, 4($sp)

__string_copy_loop:
    lb $t0, 0($a1)      # Load byte from src
    sb $t0, 0($a0)      # Store byte to dest
    beq $t0, $zero, __string_copy_done  # If null terminator, done
    addiu $a0, $a0, 1   # dest++
    addiu $a1, $a1, 1   # src++
    j __string_copy_loop

__string_copy_done:
    # Restore registers
    lw $t0, 0($sp)
    lw $t1, 4($sp)
    addiu $sp, $sp, 8
    jr $ra

__string_length:
    # Save registers
    addiu $sp, $sp, -4
    sw $t0, 0($sp)

    li $v0, 0           # length = 0
__string_length_loop:
    lb $t0, 0($a0)      # Load byte
    beq $t0, $zero, __string_length_done  # If null, done
    addiu $v0, $v0, 1   # length++
    addiu $a0, $a0, 1   # str++
    j __string_length_loop

__string_length_done:
    # Restore registers
    lw $t0, 0($sp)
    addiu $sp, $sp, 4
    jr $ra

__string_compare:
    # Save registers
    addiu $sp, $sp, -8
    sw $t0, 0($sp)
    sw $t1, 4($sp)

__string_compare_loop:
    lb $t0, 0($a0)      # Load byte from str1
    lb $t1, 0($a1)      # Load byte from str2
    bne $t0, $t1, __string_compare_not_equal  # If different, not equal
    beq $t0, $zero, __string_compare_equal  # If both null, equal
    addiu $a0, $a0, 1   # str1++
    addiu $a1, $a1, 1   # str2++
    j __string_compare_loop

__string_compare_equal:
    li $v0, 1           # Return 1 (equal)
    j __string_compare_done

__string_compare_not_equal:
    li $v0, 0           # Return 0 (not equal)

__string_compare_done:
    # Restore registers
    lw $t0, 0($sp)
    lw $t1, 4($sp)
    addiu $sp, $sp, 8
    jr $ra

