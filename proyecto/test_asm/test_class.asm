# Generated by Compiscript Compiler
# MIPS Assembly Code

# Generated by Compiscript Compiler
.data
var_nombre: .word 0  # Address: 0x1000
var_nelson: .word 0  # Address: 0x1008
# String literals
str_0: .asciiz ""
str_1: .asciiz "rojo"
str_2: .asciiz "Hola, mi nombre es "
str_3: .asciiz "Ahora tengo "
str_4: .asciiz " anios."
str_5: .asciiz "Nelson"
# String concatenation buffer
string_concat_buffer: .space 256  # 256 byte buffer for string concat


.text
.globl main

j main

# Quadruple 0: (label, None, None, FUNC_toString)
FUNC_toString:

# Quadruple 1: (enter, 4, None, None)
    # Function prologue (locals: 4 bytes)
    sw $ra, -4($sp)
    sw $fp, -8($sp)
    move $fp, $sp
    addiu $sp, $sp, -12

# Quadruple 2: (=, str_0, None, t0)
    la $t0, str_0  # Load string address

# Quadruple 3: (return, t0, None, None)
    # Return statement
    move $v0, $t0

# Quadruple 4: (leave, None, None, None)
    # Function epilogue
    addiu $sp, $fp, -8
    lw $fp, 0($sp)
    lw $ra, 4($sp)
    addiu $sp, $sp, 8
    jr $ra

# Quadruple 5: (label, None, None, FUNC_constructor (Persona))
FUNC_constructor_Persona:

# Quadruple 6: (enter, 12, None, None)
    # Function prologue (locals: 12 bytes)
    sw $ra, -4($sp)
    sw $fp, -8($sp)
    move $fp, $sp
    addiu $sp, $sp, -20

# Quadruple 7: (+, FP[4], 0, t0)  # Address of Persona.nombre
    # Address of Persona.nombre
    addiu $t0, $t1, 0

# Quadruple 8: ([]=, FP[4], None, t0)  # Store Persona.nombre
    lw $t1, 4($fp)  # Load from frame
    sw $t1, 0($t0)  # Array store

# Quadruple 9: (+, FP[8], 8, t1)  # Address of Persona.edad
    # Address of Persona.edad
    addiu $t3, $t2, 8

# Quadruple 10: ([]=, FP[8], None, t1)  # Store Persona.edad
    lw $t0, 8($fp)  # Load from frame
    sw $t0, 0($t3)  # Array store

# Quadruple 11: (=, str_1, None, t2)
    la $t4, str_1  # Load string address

# Quadruple 12: (+, t2, 12, t3)  # Address of Persona.color
    # Address of Persona.color
    addiu $t5, $t4, 12

# Quadruple 13: ([]=, t2, None, t3)  # Store Persona.color
    sw $t4, 0($t5)  # Array store

# Quadruple 14: (return, None, None, None)
    # Return statement

# Quadruple 15: (leave, None, None, None)
    # Function epilogue
    addiu $sp, $fp, -8
    lw $fp, 0($sp)
    lw $ra, 4($sp)
    addiu $sp, $sp, 8
    jr $ra

# Quadruple 16: (label, None, None, FUNC_saludar (Persona))
FUNC_saludar_Persona:

# Quadruple 17: (enter, 4, None, None)
    # Function prologue (locals: 4 bytes)
    sw $ra, -4($sp)
    sw $fp, -8($sp)
    move $fp, $sp
    addiu $sp, $sp, -12

# Quadruple 18: (=, str_2, None, t0)
    la $t0, str_2  # Load string address

# Quadruple 19: (@, FP[0], None, t1)  # Load __this pointer
    lw $t3, 0($fp)  # Load from frame

# Quadruple 20: (+, t1, 0, t2)  # Address of Persona.nombre
    # Address of Persona.nombre
    addiu $t4, $t3, 0

# Quadruple 21: ([], t2, None, t3)  # Load Persona.nombre
    lw $t5, 0($t4)  # Array load

# Quadruple 22: (+, t0, t3, t4)
    add $t6, $t0, $t5

# Quadruple 23: (return, t4, None, None)
    # Return statement
    move $v0, $t6

# Quadruple 24: (leave, None, None, None)
    # Function epilogue
    addiu $sp, $fp, -8
    lw $fp, 0($sp)
    lw $ra, 4($sp)
    addiu $sp, $sp, 8
    jr $ra

# Quadruple 25: (label, None, None, FUNC_incrementarEdad (Persona))
FUNC_incrementarEdad_Persona:

# Quadruple 26: (enter, 8, None, None)
    # Function prologue (locals: 8 bytes)
    sw $ra, -4($sp)
    sw $fp, -8($sp)
    move $fp, $sp
    addiu $sp, $sp, -16

# Quadruple 27: (@, FP[0], None, t0)  # Load __this pointer
    lw $t0, 0($fp)  # Load from frame

# Quadruple 28: (+, t0, 8, t1)  # Address of Persona.edad
    # Address of Persona.edad
    addiu $t3, $t0, 8

# Quadruple 29: ([], t1, None, t2)  # Load Persona.edad
    lw $t4, 0($t3)  # Array load

# Quadruple 30: (+, t2, FP[4], t3)
    lw $t7, 4($fp)  # Load from frame
    add $t5, $t4, $t7

# Quadruple 31: (+, t3, 8, t4)  # Address of Persona.edad
    # Address of Persona.edad
    addiu $t6, $t5, 8

# Quadruple 32: ([]=, t3, None, t4)  # Store Persona.edad
    sw $t5, 0($t6)  # Array store

# Quadruple 33: (=, str_3, None, t5)
    la $t7, str_3  # Load string address

# Quadruple 34: (@, FP[0], None, t6)  # Load __this pointer
    lw $t8, 0($fp)  # Load from frame

# Quadruple 35: (+, t6, 8, t7)  # Address of Persona.edad
    # Address of Persona.edad
    addiu $t9, $t8, 8

# Quadruple 36: ([], t7, None, t8)  # Load Persona.edad
    lw $s0, 0($t9)  # Array load

# Quadruple 37: (+, t5, t8, t9)
    add $s1, $t7, $s0

# Quadruple 38: (=, str_4, None, t10)
    la $s2, str_4  # Load string address

# Quadruple 39: (+, t9, t10, t11)
    add $s3, $s1, $s2

# Quadruple 40: (return, t11, None, None)
    # Return statement
    move $v0, $s3

# Quadruple 41: (leave, None, None, None)
    # Function epilogue
    addiu $sp, $fp, -8
    lw $fp, 0($sp)
    lw $ra, 4($sp)
    addiu $sp, $sp, 8
    jr $ra

main:
    # Main prologue
    addiu $sp, $sp, -4
    sw $ra, 0($sp)

    # Quadruple 42: (=, str_5, None, 0x1000)
    la $t9, str_5  # Load string address
    sw $t9, var_nombre

    # Quadruple 43: (=, 0x8000, None, t12)
    la $s4, 0x8000  # Load array address

    # Quadruple 44: (push, 22, None, None)
    # Push argument: 22
    li $t9, 22
    addiu $sp, $sp, -4
    sw $t9, 0($sp)

    # Quadruple 45: (push, 0x1000, None, None)
    # Push argument: 0x1000
    lw $t9, var_nombre
    addiu $sp, $sp, -4
    sw $t9, 0($sp)

    # Quadruple 46: (push, t12, None, None)  # Push __this (será FP[0])
    # Push argument: t12
    addiu $sp, $sp, -4
    sw $s4, 0($sp)

    # Quadruple 47: (call, None, None, FUNC_constructor (Persona))  # Call Persona.constructor
    # Call function: FUNC_constructor (Persona)
    jal FUNC_constructor_Persona

    # Quadruple 48: (add, SP, 12, SP)
    # Clean up arguments from stack (12 bytes)
    addiu $sp, $sp, 12

    # Quadruple 49: (pop, None, None, t13)
    # Get return value
    move $s5, $v0

    # Quadruple 50: (=, t12, None, 0x1008)
    sw $s4, var_nelson

    # Quadruple 51: (push, 0x1008, None, None)  # Push __this (será FP[0])
    # Push argument: 0x1008
    lw $t9, var_nelson
    addiu $sp, $sp, -4
    sw $t9, 0($sp)

    # Quadruple 52: (call, None, None, FUNC_saludar (Persona))  # Call Persona.saludar
    # Call function: FUNC_saludar (Persona)
    jal FUNC_saludar_Persona

    # Quadruple 53: (add, SP, 4, SP)
    # Clean up arguments from stack (4 bytes)
    addiu $sp, $sp, 4

    # Quadruple 54: (pop, None, None, t12)
    # Get return value
    move $s4, $v0

    # Quadruple 55: (print_str, t12, None, None)  # Print string
    move $a0, $s4
    li $v0, 4       # print_str
    syscall

    # Main epilogue
    lw $ra, 0($sp)
    addiu $sp, $sp, 4
    li $v0, 10  # Exit syscall
    syscall

# ===== String Runtime Functions =====

__string_copy:
    # Save registers
    addiu $sp, $sp, -8
    sw $t0, 0($sp)
    sw $t1, 4($sp)

__string_copy_loop:
    lb $t0, 0($a1)      # Load byte from src
    sb $t0, 0($a0)      # Store byte to dest
    beq $t0, $zero, __string_copy_done  # If null terminator, done
    addiu $a0, $a0, 1   # dest++
    addiu $a1, $a1, 1   # src++
    j __string_copy_loop

__string_copy_done:
    # Restore registers
    lw $t0, 0($sp)
    lw $t1, 4($sp)
    addiu $sp, $sp, 8
    jr $ra

__string_length:
    # Save registers
    addiu $sp, $sp, -4
    sw $t0, 0($sp)

    li $v0, 0           # length = 0
__string_length_loop:
    lb $t0, 0($a0)      # Load byte
    beq $t0, $zero, __string_length_done  # If null, done
    addiu $v0, $v0, 1   # length++
    addiu $a0, $a0, 1   # str++
    j __string_length_loop

__string_length_done:
    # Restore registers
    lw $t0, 0($sp)
    addiu $sp, $sp, 4
    jr $ra

__string_compare:
    # Save registers
    addiu $sp, $sp, -8
    sw $t0, 0($sp)
    sw $t1, 4($sp)

__string_compare_loop:
    lb $t0, 0($a0)      # Load byte from str1
    lb $t1, 0($a1)      # Load byte from str2
    bne $t0, $t1, __string_compare_not_equal  # If different, not equal
    beq $t0, $zero, __string_compare_equal  # If both null, equal
    addiu $a0, $a0, 1   # str1++
    addiu $a1, $a1, 1   # str2++
    j __string_compare_loop

__string_compare_equal:
    li $v0, 1           # Return 1 (equal)
    j __string_compare_done

__string_compare_not_equal:
    li $v0, 0           # Return 0 (not equal)

__string_compare_done:
    # Restore registers
    lw $t0, 0($sp)
    lw $t1, 4($sp)
    addiu $sp, $sp, 8
    jr $ra

