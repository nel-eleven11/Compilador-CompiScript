# classes/MIPS_generator/mips_generator.py
"""
MIPSGenerator - Generador principal de código MIPS desde cuádruplos TAC
"""

from .register_allocator import RegisterAllocator
from .mips_stack_manager import MIPSStackManager
from .mips_runtime import MIPSRuntime

class MIPSGenerator:
    def __init__(self, code_generator, symbol_table):
        """
        Inicializa el generador de MIPS

        Args:
            code_generator: El CodeGenerator que contiene los cuádruplos
            symbol_table: La tabla de símbolos del programa
        """
        self.cg = code_generator
        self.symbol_table = symbol_table
        self.memory_manager = code_generator.memory_manager
        self.register_allocator = RegisterAllocator()
        self.stack_manager = MIPSStackManager()
        self.runtime = MIPSRuntime()

        # Instrucciones MIPS generadas
        self.data_section = []
        self.text_section = []

        # Contexto de función actual durante la traducción
        self.current_function = None
        self.param_registers = []  # Para rastrear argumentos durante llamadas

    def generate_mips_code(self):
        """Genera código MIPS completo desde los cuádruplos"""
        # 1. Sección de datos (variables globales)
        self._generate_data_section()

        # 2. Sección de texto (código ejecutable)
        self._generate_text_section()

        # 3. Ensamblar archivo final
        return self._assemble_final_code()

    def _generate_data_section(self):
        """Genera la sección .data con variables globales"""
        self.data_section.append("# Generated by Compiscript Compiler")
        self.data_section.append(".data")

        # Obtener todas las variables globales del memory manager
        # Include both regular variables (0x1000-0x7FFF) and arrays (0x8000+)
        global_vars = {name: addr for name, addr in self.memory_manager.allocations.items()
                      if isinstance(addr, int) and addr >= 0x1000}

        # Ordenar por dirección
        sorted_vars = sorted(global_vars.items(), key=lambda x: x[1])

        for var_name, address in sorted_vars:
            # Check if this is an array (address >= 0x8000)
            if address >= 0x8000:
                # For arrays, allocate space for multiple words (assuming 10 elements for now)
                # This is a simplification - ideally we'd know the actual array size
                self.data_section.append(f"var_{var_name}: .space 40  # Array at {hex(address)} (10 words)")
            else:
                # Regular variable
                self.data_section.append(f"var_{var_name}: .word 0  # Address: {hex(address)}")

        # Add string literals
        string_literals = self.cg.get_string_literals()
        if string_literals:
            self.data_section.append("# String literals")
            for string_value, label in string_literals.items():
                # Remove quotes and escape special characters for MIPS
                string_content = string_value[1:-1]  # Remove surrounding quotes
                # Escape backslashes and quotes
                string_content = string_content.replace('\\', '\\\\').replace('"', '\\"')
                self.data_section.append(f'{label}: .asciiz "{string_content}"')

        # Add string concatenation buffer
        self.data_section.append("# String concatenation buffer")
        self.data_section.append("string_concat_buffer: .space 256  # 256 byte buffer for string concat")

        self.data_section.append("")

    def _generate_text_section(self):
        """Genera la sección .text con el código principal"""
        self.text_section.append(".text")
        self.text_section.append(".globl main")
        self.text_section.append("")

        # CRITICAL: Jump to main at the start to skip function definitions
        self.text_section.append("j main")
        self.text_section.append("")

        # Separate function quadruples from main quadruples
        function_quads = []
        main_quads = []
        current_function = None
        in_function = False

        for idx, quad in enumerate(self.cg.quadruples):
            # Check if this is a function label (starts with FUNC_)
            if quad.op == 'label' and isinstance(quad.result, str) and quad.result.startswith('FUNC_'):
                in_function = True
                current_function = []
                function_quads.append((idx, current_function))

            if in_function:
                current_function.append((idx, quad))
                # Check if function ends with 'leave'
                if quad.op == 'leave':
                    in_function = False
                    current_function = None
            else:
                main_quads.append((idx, quad))

        # Generate all functions first
        for func_idx, func_quads in function_quads:
            for idx, quad in func_quads:
                self.text_section.append(f"# Quadruple {idx}: {quad}")
                instructions = self._translate_quadruple(quad)
                for instruction in instructions:
                    if instruction.strip():
                        # Function labels should not be indented
                        if instruction.strip().endswith(':') and not instruction.strip().startswith('L'):
                            self.text_section.append(instruction.strip())
                        else:
                            self.text_section.append(f"    {instruction}")
                self.text_section.append("")

        # Generate main section
        self.text_section.append("main:")
        self.text_section.append("    # Main prologue")
        self.text_section.append("    addiu $sp, $sp, -4")
        self.text_section.append("    sw $ra, 0($sp)")
        self.text_section.append("")

        # Traducir cuádruplos del main
        for idx, quad in main_quads:
            self.text_section.append(f"    # Quadruple {idx}: {quad}")
            instructions = self._translate_quadruple(quad)
            for instruction in instructions:
                if instruction.strip():
                    self.text_section.append(f"    {instruction}")
            self.text_section.append("")

        # Epílogo del main
        self.text_section.append("    # Main epilogue")
        self.text_section.append("    lw $ra, 0($sp)")
        self.text_section.append("    addiu $sp, $sp, 4")
        self.text_section.append("    li $v0, 10  # Exit syscall")
        self.text_section.append("    syscall")

    def _translate_quadruple(self, quad):
        """
        Traduce un cuádruplo individual a instrucciones MIPS

        Args:
            quad: El cuádruplo a traducir

        Returns:
            Lista de instrucciones MIPS
        """
        op = quad.op

        # Operaciones aritméticas (including special stack operations)
        if op == '+' or op == 'add':
            # Check if this is stack cleanup: (add, SP, size, SP)
            if (quad.arg1 == 'SP' or str(quad.arg1).upper() == 'SP') and (quad.result == 'SP' or str(quad.result).upper() == 'SP'):
                return self._translate_function_quad(quad)
            elif op == '+':
                return self._translate_arithmetic_quad(quad)
            else:
                # 'add' without SP is still a function-related operation
                return self._translate_function_quad(quad)
        elif op in ['-', '*', '/']:
            return self._translate_arithmetic_quad(quad)

        # Operaciones de asignación
        elif op == '=':
            return self._translate_assignment_quad(quad)

        # Operaciones de carga (@)
        elif op == '@':
            return self._translate_load_quad(quad)

        # Operaciones de comparación
        elif op in ['<', '>', '<=', '>=', '==', '!=']:
            return self._translate_comparison_quad(quad)

        # Operaciones lógicas
        elif op in ['&&', '||', '!']:
            return self._translate_logical_quad(quad)

        # Operaciones unarias
        elif op in ['-', 'NEG'] and quad.arg2 is None:
            return self._translate_unary_quad(quad)

        # Operación de módulo
        elif op == '%':
            return self._translate_modulo_quad(quad)

        # Operaciones de salto
        elif op in ['goto', 'if', 'if_false', 'ifFalse']:
            return self._translate_jump_quad(quad)

        # Operaciones de función
        elif op in ['call', 'param', 'return', 'enter', 'leave', 'push', 'pop']:
            return self._translate_function_quad(quad)

        # Operación de etiqueta
        elif op == 'label':
            return self._translate_label_quad(quad)

        # Operaciones de print
        elif op in ['print_int', 'print_str']:
            return self._translate_print_quad(quad)

        # Operaciones de arrays
        elif op == '[]':
            return self._translate_array_load_quad(quad)
        elif op == '[]=':
            return self._translate_array_store_quad(quad)

        else:
            return [f"# TODO: Translate operation '{op}'"]

    def _translate_arithmetic_quad(self, quad):
        """
        Traduce cuádruplos aritméticos: (op, arg1, arg2, result)
        Ejemplo: (+, t0, t1, t2) -> add $t2, $t0, $t1

        Special case: String concatenation when op is '+' and operands are strings
        """
        instructions = []

        # Check if this is string concatenation (+ operator with string operands)
        if quad.op == '+' and self._might_be_string_concat(quad.arg1, quad.arg2):
            return self._translate_string_concat(quad)

        # Acceso a objeto (dirección de atributo): (+, base, offset, result) 'Address of ...'
        if self._is_object_address_quad(quad):
            return self._translate_object_access(quad)

        # Mapeo de operadores TAC a MIPS
        mips_ops = {
            '+': 'add',
            '-': 'sub',
            '*': 'mul',
            '/': 'div'
        }

        mips_op = mips_ops.get(quad.op)
        if not mips_op:
            return [f"# ERROR: Unknown arithmetic operation '{quad.op}'"]

        # Result is always a temporary - allocate FIRST
        result_reg = self.register_allocator.get_reg(quad.result)

        # IMPORTANT: Allocate registers for TEMPORARY operands FIRST
        # This ensures they're marked as used before we pick registers for non-temporaries
        arg1_reg = None
        arg2_reg = None

        if self._is_temporary(quad.arg1):
            arg1_reg = self.register_allocator.get_reg(quad.arg1)
        if self._is_temporary(quad.arg2):
            arg2_reg = self.register_allocator.get_reg(quad.arg2)

        # Now allocate for non-temporaries, avoiding already-allocated registers
        if arg1_reg is None:
            # arg1 is not a temporary, pick an available temp register
            for reg in ['$t0', '$t1', '$t2', '$t3', '$t4', '$t5', '$t6', '$t7', '$t8', '$t9']:
                if reg != result_reg and reg != arg2_reg and reg not in self.register_allocator.used_regs:
                    arg1_reg = reg
                    break
            # If no temp register available, use $at (but not if arg2 is already using it)
            if not arg1_reg:
                if arg2_reg != '$at':
                    arg1_reg = '$at'
                elif arg2_reg != '$t9':
                    # arg2 is using $at, so use $t9 if arg2 isn't using it
                    arg1_reg = '$t9'
                else:
                    # Both $at and $t9 are taken, use $t8
                    arg1_reg = '$t8'

        if arg2_reg is None:
            # arg2 is not a temporary, pick an available temp register different from arg1
            for reg in ['$t0', '$t1', '$t2', '$t3', '$t4', '$t5', '$t6', '$t7', '$t8', '$t9']:
                if reg != result_reg and reg != arg1_reg and reg not in self.register_allocator.used_regs:
                    arg2_reg = reg
                    break
            # If no temp register available, use $at (but not if arg1 is already using it)
            if not arg2_reg:
                if arg1_reg != '$at':
                    arg2_reg = '$at'
                elif arg1_reg != '$t9':
                    # arg1 is using $at, so use $t9 if arg1 isn't using it
                    arg2_reg = '$t9'
                else:
                    # Both $at and $t9 are taken, use $t8
                    arg2_reg = '$t8'

        # Cargar arg1 - CHECK MEMORY ADDRESS FIRST!
        if self._is_temporary(quad.arg1):
            # Si es temporal, ya debería estar en registro
            pass
        elif self._is_fp_relative(quad.arg1):
            # FP-relative addressing: FP[offset]
            offset = self._extract_fp_offset(quad.arg1)
            instructions.append(f"lw {arg1_reg}, {offset}($fp)  # Load from frame")
        elif isinstance(quad.arg1, str) and quad.arg1.startswith('0x'):
            # Es una dirección de memoria - check if it's an array
            try:
                addr_int = int(quad.arg1, 16)
                if addr_int >= 0x8000:
                    # Array address - load ADDRESS not value
                    addr = self._get_memory_label(quad.arg1)
                    instructions.append(f"la {arg1_reg}, {addr}")
                else:
                    # Regular variable - load value
                    addr = self._get_memory_label(quad.arg1)
                    instructions.append(f"lw {arg1_reg}, {addr}")
            except ValueError:
                # Not a valid hex, load as variable
                addr = self._get_memory_label(quad.arg1)
                instructions.append(f"lw {arg1_reg}, {addr}")
        elif self._is_immediate(quad.arg1):
            # If arg2 is also immediate, ensure we load into different register by using $at temporarily
            if self._is_immediate(quad.arg2) and not self._is_temporary(quad.arg2):
                # Use $at for arg1 to avoid conflict
                instructions.append(f"li $at, {quad.arg1}")
                arg1_reg = '$at'
            else:
                instructions.append(f"li {arg1_reg}, {quad.arg1}")
        else:
            # Es una variable, cargar desde memoria
            addr = self._get_memory_label(quad.arg1)
            instructions.append(f"lw {arg1_reg}, {addr}")

        # Cargar arg2 - CHECK MEMORY ADDRESS FIRST!
        if self._is_temporary(quad.arg2):
            # Si es temporal, ya debería estar en registro
            pass
        elif self._is_fp_relative(quad.arg2):
            # FP-relative addressing: FP[offset]
            offset = self._extract_fp_offset(quad.arg2)
            instructions.append(f"lw {arg2_reg}, {offset}($fp)  # Load from frame")
        elif isinstance(quad.arg2, str) and quad.arg2.startswith('0x'):
            # Es una dirección de memoria - check if it's an array
            try:
                addr_int = int(quad.arg2, 16)
                if addr_int >= 0x8000:
                    # Array address - load ADDRESS not value
                    addr = self._get_memory_label(quad.arg2)
                    instructions.append(f"la {arg2_reg}, {addr}")
                else:
                    # Regular variable - load value
                    addr = self._get_memory_label(quad.arg2)
                    instructions.append(f"lw {arg2_reg}, {addr}")
            except ValueError:
                # Not a valid hex, load as variable
                addr = self._get_memory_label(quad.arg2)
                instructions.append(f"lw {arg2_reg}, {addr}")
        elif self._is_immediate(quad.arg2):
            # For immediates, prefer using $at to avoid overwriting allocated temporaries
            # Unless arg1 already used $at, then use the allocated arg2_reg
            if arg1_reg == '$at' or not self._is_temporary(quad.arg1):
                # arg1 used $at OR arg1 is not a temporary, so use allocated reg for arg2
                instructions.append(f"li {arg2_reg}, {quad.arg2}")
            else:
                # arg1 is a temporary in its own register, safe to use $at for arg2
                instructions.append(f"li $at, {quad.arg2}")
                arg2_reg = '$at'
        else:
            # Es una variable, cargar desde memoria
            addr = self._get_memory_label(quad.arg2)
            instructions.append(f"lw {arg2_reg}, {addr}")

        # Realizar la operación
        if quad.op == '/':
            # División es especial en MIPS
            instructions.append(f"div {arg1_reg}, {arg2_reg}")
            instructions.append(f"mflo {result_reg}  # quotient")
        else:
            instructions.append(f"{mips_op} {result_reg}, {arg1_reg}, {arg2_reg}")

        return instructions

    def _translate_assignment_quad(self, quad):
        """
        Traduce cuádruplos de asignación: (=, value, None, target)
        Ejemplo: (=, 5, None, 0x1000) -> li $t0, 5; sw $t0, var_a
        """
        instructions = []

        value = quad.arg1
        target = quad.result

        # Detectar si estamos asignando una dirección de array a un temporal
        # Si es así, usar un registro $s en lugar de $t para evitar sobrescritura
        is_array_address_assignment = False
        if self._is_temporary(target) and isinstance(value, str) and value.startswith('0x'):
            try:
                addr_int = int(value, 16)
                if addr_int >= 0x8000:
                    is_array_address_assignment = True
            except ValueError:
                pass

        # Si el target es temporal, asignar su registro PRIMERO
        # Esto evita conflictos donde value_reg y target_reg son el mismo
        target_reg = None
        if self._is_temporary(target):
            # CLAVE: Usar contexto 'save' para arrays para obtener registro $s
            context = 'save' if is_array_address_assignment else 'arithmetic'
            target_reg = self.register_allocator.get_reg(target, context=context)

        # Obtener registro para el valor
        if self._is_temporary(value):
            # Si es temporal, obtener su registro
            value_reg = self.register_allocator.get_reg(value)
        else:
            # Para valores no-temporales:
            # Si target es temporal, cargar directamente en target_reg
            # Si no, usar un registro temporal
            if target_reg:
                value_reg = target_reg
            else:
                value_reg = self.register_allocator.get_reg_temp("assign_temp")
            # Cargar el valor usando el helper
            self._load_value_to_reg(value, value_reg, instructions)

        # Guardar en el target
        if self._is_temporary(target):
            # Si target es temporal, mover a su registro (si es diferente)
            if value_reg != target_reg:
                instructions.append(f"move {target_reg}, {value_reg}")
        elif self._is_fp_relative(target):
            # Target es FP-relative (local variable or parameter)
            offset = self._extract_fp_offset(target)
            instructions.append(f"sw {value_reg}, {offset}($fp)")
        elif isinstance(target, str) and target.startswith('0x'):
            # Target es una dirección de memoria
            try:
                addr_int = int(target, 16)
                if addr_int >= 0x8000:
                    # Es un array - esto no debería pasar en una asignación normal
                    # Arrays se modifican vía indexed store
                    target_addr = self._get_memory_label(target)
                    instructions.append(f"sw {value_reg}, {target_addr}")
                else:
                    # Variable regular
                    target_addr = self._get_memory_label(target)
                    instructions.append(f"sw {value_reg}, {target_addr}")
            except ValueError:
                target_addr = self._get_memory_label(target)
                instructions.append(f"sw {value_reg}, {target_addr}")
        else:
            # Es una variable o dirección, guardar en memoria
            target_addr = self._get_memory_label(target)
            instructions.append(f"sw {value_reg}, {target_addr}")

        return instructions

    def _translate_load_quad(self, quad):
        """
        Traduce cuádruplos de carga: (@, addr, None, temp)
        Ejemplos:
        - (@, 0x1000, None, t0) -> lw $t0, var_a
        - (@, FP[8], None, t0) -> lw $t0, 8($fp)  # Parameter/local access
        """
        instructions = []

        addr = quad.arg1
        target_temp = quad.result

        # Obtener registro para el temporal
        target_reg = self.register_allocator.get_reg(target_temp)

        # Check if this is FP-relative addressing (parameters/locals)
        if isinstance(addr, str) and addr.startswith('FP[') and addr.endswith(']'):
            # Extract offset from FP[offset]
            offset_str = addr[3:-1]  # Remove "FP[" and "]"
            offset = offset_str
            instructions.append(f"lw {target_reg}, {offset}($fp)  # Load from frame")
        else:
            # Regular memory load
            source_addr = self._get_memory_label(addr)
            instructions.append(f"lw {target_reg}, {source_addr}")

        return instructions

    def _translate_comparison_quad(self, quad):
        """
        Traduce cuádruplos de comparación: (op, arg1, arg2, result)
        Ejemplo: (<, t0, t1, t2) -> slt $t2, $t0, $t1

        Special case: String comparison for == and !=

        En MIPS, las comparaciones usan:
        - slt (set less than): result = 1 si arg1 < arg2, 0 si no
        - seq (set equal): result = 1 si arg1 == arg2, 0 si no
        - sne (set not equal): result = 1 si arg1 != arg2, 0 si no
        - Para <=, >, >= usamos combinaciones
        """
        instructions = []

        # Check if this is string comparison (use stricter detection)
        if quad.op in ['==', '!='] and self._might_be_string_comparison(quad.arg1, quad.arg2):
            return self._translate_string_comparison(quad)

        # Obtener registros para los operandos
        # For arg1: use get_reg if it's a temporary, otherwise get a temp register
        if self._is_temporary(quad.arg1):
            arg1_reg = self.register_allocator.get_reg(quad.arg1)
        else:
            arg1_reg = self.register_allocator.get_reg_temp("arg1")

        # For arg2: use get_reg if it's a temporary, otherwise get a temp register
        if self._is_temporary(quad.arg2):
            arg2_reg = self.register_allocator.get_reg(quad.arg2)
        else:
            arg2_reg = self.register_allocator.get_reg_temp("arg2")

        # Result is always a temporary
        result_reg = self.register_allocator.get_reg(quad.result)

        # Cargar arg1 - CHECK MEMORY ADDRESS FIRST!
        if self._is_temporary(quad.arg1):
            # Si es temporal, ya debería estar en registro
            pass
        elif self._is_fp_relative(quad.arg1):
            # FP-relative addressing: FP[offset]
            offset = self._extract_fp_offset(quad.arg1)
            instructions.append(f"lw {arg1_reg}, {offset}($fp)  # Load from frame")
        elif isinstance(quad.arg1, str) and quad.arg1.startswith('0x'):
            # Es una dirección de memoria - check if it's an array
            try:
                addr_int = int(quad.arg1, 16)
                if addr_int >= 0x8000:
                    # Array address - load ADDRESS not value
                    addr = self._get_memory_label(quad.arg1)
                    instructions.append(f"la {arg1_reg}, {addr}")
                else:
                    # Regular variable - load value
                    addr = self._get_memory_label(quad.arg1)
                    instructions.append(f"lw {arg1_reg}, {addr}")
            except ValueError:
                # Not a valid hex, load as variable
                addr = self._get_memory_label(quad.arg1)
                instructions.append(f"lw {arg1_reg}, {addr}")
        elif self._is_immediate(quad.arg1):
            instructions.append(f"li {arg1_reg}, {quad.arg1}")
        else:
            # Es una variable, cargar desde memoria
            addr = self._get_memory_label(quad.arg1)
            instructions.append(f"lw {arg1_reg}, {addr}")

        # Cargar arg2 - CHECK MEMORY ADDRESS FIRST!
        if self._is_temporary(quad.arg2):
            # Si es temporal, ya debería estar en registro
            pass
        elif self._is_fp_relative(quad.arg2):
            # FP-relative addressing: FP[offset]
            offset = self._extract_fp_offset(quad.arg2)
            instructions.append(f"lw {arg2_reg}, {offset}($fp)  # Load from frame")
        elif isinstance(quad.arg2, str) and quad.arg2.startswith('0x'):
            # Es una dirección de memoria - check if it's an array
            try:
                addr_int = int(quad.arg2, 16)
                if addr_int >= 0x8000:
                    # Array address - load ADDRESS not value
                    addr = self._get_memory_label(quad.arg2)
                    instructions.append(f"la {arg2_reg}, {addr}")
                else:
                    # Regular variable - load value
                    addr = self._get_memory_label(quad.arg2)
                    instructions.append(f"lw {arg2_reg}, {addr}")
            except ValueError:
                # Not a valid hex, load as variable
                addr = self._get_memory_label(quad.arg2)
                instructions.append(f"lw {arg2_reg}, {addr}")
        elif self._is_immediate(quad.arg2):
            instructions.append(f"li {arg2_reg}, {quad.arg2}")
        else:
            # Es una variable, cargar desde memoria
            addr = self._get_memory_label(quad.arg2)
            instructions.append(f"lw {arg2_reg}, {addr}")

        # Realizar la comparación
        if quad.op == '<':
            # slt: set less than
            instructions.append(f"slt {result_reg}, {arg1_reg}, {arg2_reg}")

        elif quad.op == '<=':
            # <= es equivalente a: NOT (arg1 > arg2)
            # arg1 <= arg2 es lo mismo que arg2 >= arg1
            # Usamos: slt $temp, arg2, arg1; xori result, $temp, 1
            temp_reg = self.register_allocator.get_reg_temp("cmp_temp")
            instructions.append(f"slt {temp_reg}, {arg2_reg}, {arg1_reg}")  # temp = arg2 < arg1
            instructions.append(f"xori {result_reg}, {temp_reg}, 1")  # result = NOT temp

        elif quad.op == '>':
            # > es lo mismo que arg2 < arg1
            instructions.append(f"slt {result_reg}, {arg2_reg}, {arg1_reg}")

        elif quad.op == '>=':
            # >= es equivalente a: NOT (arg1 < arg2)
            temp_reg = self.register_allocator.get_reg_temp("cmp_temp")
            instructions.append(f"slt {temp_reg}, {arg1_reg}, {arg2_reg}")  # temp = arg1 < arg2
            instructions.append(f"xori {result_reg}, {temp_reg}, 1")  # result = NOT temp

        elif quad.op == '==':
            # == : xor + seq (set equal to zero)
            # Si arg1 == arg2, entonces arg1 XOR arg2 = 0
            instructions.append(f"xor {result_reg}, {arg1_reg}, {arg2_reg}")
            instructions.append(f"sltiu {result_reg}, {result_reg}, 1")  # result = (result == 0)

        elif quad.op == '!=':
            # != : xor + sne (set not equal to zero)
            # Si arg1 != arg2, entonces arg1 XOR arg2 != 0
            instructions.append(f"xor {result_reg}, {arg1_reg}, {arg2_reg}")
            instructions.append(f"sltu {result_reg}, $zero, {result_reg}")  # result = (result != 0)

        return instructions

    def _translate_logical_quad(self, quad):
        """
        Traduce operaciones lógicas: &&, ||, !

        Para operaciones lógicas simples (sin cortocircuito en cuádruplos):
        - && : AND bit a bit
        - || : OR bit a bit
        - ! : NOT lógico (invertir booleano)

        Nota: Si el código intermedio ya maneja cortocircuito con labels,
        esas operaciones se traducen como comparaciones + saltos.
        """
        instructions = []

        if quad.op == '!':
            # NOT lógico: (!, operand, None, result)
            # En MIPS: xori result, operand, 1 (invertir bit)
            # O también: seq result, operand, $zero (result = operand == 0)

            operand = quad.arg1
            result = quad.result

            # Obtener registros
            operand_reg = self.register_allocator.get_reg(operand)
            result_reg = self.register_allocator.get_reg(result)

            # Cargar operando usando helper
            if not self._is_temporary(operand):
                self._load_value_to_reg(operand, operand_reg, instructions)

            # NOT lógico: result = (operand == 0) ? 1 : 0
            instructions.append(f"sltiu {result_reg}, {operand_reg}, 1")

        elif quad.op == '&&':
            # AND lógico: (&&, arg1, arg2, result)
            # Nota: Si hay cortocircuito, esto se traduce con labels
            # Aquí implementamos AND simple bit a bit

            arg1 = quad.arg1
            arg2 = quad.arg2
            result = quad.result

            # Obtener registros
            arg1_reg = self.register_allocator.get_reg(arg1)
            arg2_reg = self.register_allocator.get_reg(arg2)
            result_reg = self.register_allocator.get_reg(result)

            # Cargar arg1
            if self._is_temporary(arg1):
                pass
            elif self._is_immediate(arg1):
                instructions.append(f"li {arg1_reg}, {arg1}")
            else:
                addr = self._get_memory_label(arg1)
                instructions.append(f"lw {arg1_reg}, {addr}")

            # Cargar arg2
            if self._is_temporary(arg2):
                pass
            elif self._is_immediate(arg2):
                instructions.append(f"li {arg2_reg}, {arg2}")
            else:
                addr = self._get_memory_label(arg2)
                instructions.append(f"lw {arg2_reg}, {addr}")

            # AND bit a bit
            instructions.append(f"and {result_reg}, {arg1_reg}, {arg2_reg}")
            # Normalizar a booleano (0 o 1)
            instructions.append(f"sltu {result_reg}, $zero, {result_reg}")

        elif quad.op == '||':
            # OR lógico: (||, arg1, arg2, result)

            arg1 = quad.arg1
            arg2 = quad.arg2
            result = quad.result

            # Obtener registros
            arg1_reg = self.register_allocator.get_reg(arg1)
            arg2_reg = self.register_allocator.get_reg(arg2)
            result_reg = self.register_allocator.get_reg(result)

            # Cargar arg1
            if self._is_temporary(arg1):
                pass
            elif self._is_immediate(arg1):
                instructions.append(f"li {arg1_reg}, {arg1}")
            else:
                addr = self._get_memory_label(arg1)
                instructions.append(f"lw {arg1_reg}, {addr}")

            # Cargar arg2
            if self._is_temporary(arg2):
                pass
            elif self._is_immediate(arg2):
                instructions.append(f"li {arg2_reg}, {arg2}")
            else:
                addr = self._get_memory_label(arg2)
                instructions.append(f"lw {arg2_reg}, {addr}")

            # OR bit a bit
            instructions.append(f"or {result_reg}, {arg1_reg}, {arg2_reg}")
            # Normalizar a booleano (0 o 1)
            instructions.append(f"sltu {result_reg}, $zero, {result_reg}")

        return instructions

    def _translate_unary_quad(self, quad):
        """
        Traduce operaciones unarias

        Principalmente la negación aritmética: -x
        Cuádruplo: (-, operand, None, result) o (NEG, operand, None, result)
        """
        instructions = []

        if quad.op in ['-', 'NEG']:
            # Negación aritmética: (-, operand, None, result)
            # En MIPS: sub result, $zero, operand
            # O también: neg result, operand (pseudo-instrucción)

            operand = quad.arg1
            result = quad.result

            # Obtener registros
            operand_reg = self.register_allocator.get_reg(operand)
            result_reg = self.register_allocator.get_reg(result)

            # Cargar operando si es necesario
            if self._is_temporary(operand):
                pass
            elif self._is_immediate(operand):
                instructions.append(f"li {operand_reg}, {operand}")
            else:
                addr = self._get_memory_label(operand)
                instructions.append(f"lw {operand_reg}, {addr}")

            # Negar: result = 0 - operand
            instructions.append(f"sub {result_reg}, $zero, {operand_reg}")

        return instructions

    def _translate_modulo_quad(self, quad):
        """
        Traduce operación de módulo: (%, arg1, arg2, result)

        En MIPS:
        - div arg1, arg2  (divide arg1 / arg2)
        - mfhi result     (obtener resto/módulo)
        """
        instructions = []

        arg1 = quad.arg1
        arg2 = quad.arg2
        result = quad.result

        # Obtener registros
        arg1_reg = self.register_allocator.get_reg(arg1)
        arg2_reg = self.register_allocator.get_reg(arg2)
        result_reg = self.register_allocator.get_reg(result)

        # Cargar arg1
        if self._is_temporary(arg1):
            pass
        elif self._is_immediate(arg1):
            instructions.append(f"li {arg1_reg}, {arg1}")
        else:
            addr = self._get_memory_label(arg1)
            instructions.append(f"lw {arg1_reg}, {addr}")

        # Cargar arg2
        if self._is_temporary(arg2):
            pass
        elif self._is_immediate(arg2):
            instructions.append(f"li {arg2_reg}, {arg2}")
        else:
            addr = self._get_memory_label(arg2)
            instructions.append(f"lw {arg2_reg}, {addr}")

        # División y obtener resto
        instructions.append(f"div {arg1_reg}, {arg2_reg}")
        instructions.append(f"mfhi {result_reg}  # Get remainder (modulo)")

        return instructions

    def _translate_jump_quad(self, quad):
        """
        Traduce cuádruplos de salto y control de flujo

        Tipos de saltos:
        - goto: Salto incondicional
        - if: Salto si la condición es verdadera (!=0)
        - if_false/ifFalse: Salto si la condición es falsa (==0)
        """
        instructions = []

        if quad.op == 'goto':
            # Salto incondicional: (goto, None, None, label)
            label = self._sanitize_label(quad.result)
            instructions.append(f"j {label}")

        elif quad.op in ['if', 'if_true']:
            # Salto condicional si verdadero: (if, condition, None, label)
            # En MIPS: bne condition, $zero, label (branch if not equal to zero)
            condition = quad.arg1
            label = self._sanitize_label(quad.result)

            # Obtener registro de la condición
            cond_reg = self.register_allocator.get_reg(condition)

            # Cargar condición si es necesario
            if self._is_temporary(condition):
                # Ya está en registro
                pass
            elif self._is_immediate(condition):
                normalized = self._normalize_value(condition)
                instructions.append(f"li {cond_reg}, {normalized}")
            else:
                # Es una variable
                addr = self._get_memory_label(condition)
                instructions.append(f"lw {cond_reg}, {addr}")

            # Branch if not equal to zero (si es verdadero)
            instructions.append(f"bne {cond_reg}, $zero, {label}")

        elif quad.op in ['if_false', 'ifFalse']:
            # Salto condicional si falso: (if_false, condition, None, label)
            # En MIPS: beq condition, $zero, label (branch if equal to zero)
            condition = quad.arg1
            label = self._sanitize_label(quad.result)

            # Obtener registro de la condición
            cond_reg = self.register_allocator.get_reg(condition)

            # Cargar condición si es necesario
            if self._is_temporary(condition):
                # Ya está en registro
                pass
            elif self._is_immediate(condition):
                normalized = self._normalize_value(condition)
                instructions.append(f"li {cond_reg}, {normalized}")
            else:
                # Es una variable
                addr = self._get_memory_label(condition)
                instructions.append(f"lw {cond_reg}, {addr}")

            # Branch if equal to zero (si es falso)
            instructions.append(f"beq {cond_reg}, $zero, {label}")

        return instructions

    def _translate_label_quad(self, quad):
        """
        Traduce cuádruplos de etiqueta: (label, None, None, L0)
        Simplemente genera la etiqueta en MIPS
        """
        label_name = self._sanitize_label(quad.result)
        return [f"{label_name}:"]

    def _translate_print_quad(self, quad):
        """
        Traduce cuádruplos de print: (print_int, value, None, None)
        Imprime un valor usando syscalls de MIPS

        Args:
            quad: Cuádruplo con op='print_int' o 'print_str'

        Returns:
            Lista de instrucciones MIPS
        """
        instructions = []
        value = quad.arg1

        if quad.op == 'print_int':
            # Cargar el valor en $a0 usando el método helper existente
            if self._is_temporary(value):
                # Es un temporal
                value_reg = self.register_allocator.get_reg(value)
                instructions.append(f"move $a0, {value_reg}")
            elif self._is_fp_relative(value):
                # Es una variable local (FP[offset])
                offset = self._extract_fp_offset(value)
                instructions.append(f"lw $a0, {offset}($fp)")
            elif isinstance(value, str) and value.startswith('0x'):
                # Es una dirección de memoria global (0x1000, etc.)
                var_label = self._get_memory_label(value)
                instructions.append(f"lw $a0, {var_label}")
            elif self._is_immediate(value):
                # Es un literal
                normalized = self._normalize_value(value)
                instructions.append(f"li $a0, {normalized}")
            else:
                # Cualquier otro caso - intentar cargar desde etiqueta
                var_label = self._get_memory_label(value)
                instructions.append(f"lw $a0, {var_label}")

            # Syscall para imprimir entero
            instructions.append("li $v0, 1       # print_int")
            instructions.append("syscall")

            # Opcional: imprimir newline después del número
            instructions.append("li $v0, 11      # print_char")
            instructions.append("li $a0, 10      # newline")
            instructions.append("syscall")

        elif quad.op == 'print_str':
            # Para strings, el valor es una etiqueta (ej: str_0) o un temporal que contiene una etiqueta
            if self._is_temporary(value):
                # Es un temporal que contiene la dirección del string
                value_reg = self.register_allocator.get_reg(value)
                instructions.append(f"move $a0, {value_reg}")
            elif isinstance(value, str) and value.startswith('str_'):
                # Es una etiqueta de string literal directamente
                instructions.append(f"la $a0, {value}")
            elif self._is_fp_relative(value):
                # Es una variable local (FP[offset])
                offset = self._extract_fp_offset(value)
                instructions.append(f"lw $a0, {offset}($fp)")
            elif isinstance(value, str) and value.startswith('0x'):
                # Es una dirección de memoria global
                var_label = self._get_memory_label(value)
                instructions.append(f"lw $a0, {var_label}")
            else:
                # Cualquier otro caso - asumir que es una etiqueta
                instructions.append(f"la $a0, {value}")

            # Syscall para imprimir string
            instructions.append("li $v0, 4       # print_str")
            instructions.append("syscall")

        return instructions

    def _translate_array_load_quad(self, quad):
        """
        Traduce cuádruplos de carga desde array: ([], addr, None, result)
        Carga el valor desde la dirección en addr al result

        Args:
            quad: Cuádruplo con op='[]', arg1=dirección efectiva

        Returns:
            Lista de instrucciones MIPS
        """
        instructions = []
        addr = quad.arg1
        result = quad.result

        # Obtener la dirección efectiva en un registro
        if self._is_temporary(addr):
            addr_reg = self.register_allocator.get_reg(addr)
        elif self._is_fp_relative(addr):
            offset = self._extract_fp_offset(addr)
            addr_reg = self.register_allocator.get_reg_temp("addr")
            instructions.append(f"lw {addr_reg}, {offset}($fp)")
        else:
            # Cargar dirección inmediata
            addr_reg = self.register_allocator.get_reg_temp("addr")
            instructions.append(f"li {addr_reg}, {addr}")

        # Cargar el valor desde la dirección
        result_reg = self.register_allocator.get_reg(result)
        instructions.append(f"lw {result_reg}, 0({addr_reg})  # Array load")

        return instructions

    def _translate_array_store_quad(self, quad):
        """
        Traduce cuádruplos de almacenamiento en array: ([]=, value, None, addr_temp)
        Almacena value en la dirección contenida en addr_temp

        Args:
            quad: Cuádruplo con op='[]='
            Format: ([]=, value_temp, None, effective_address_temp)

        Returns:
            Lista de instrucciones MIPS
        """
        instructions = []
        value = quad.arg1
        addr = quad.result  # La dirección efectiva está en result, no en arg2

        # IMPORTANT: Get address register FIRST to avoid conflicts
        # Obtener la dirección destino PRIMERO
        if self._is_temporary(addr):
            addr_reg = self.register_allocator.get_reg(addr)
        elif self._is_fp_relative(addr):
            offset = self._extract_fp_offset(addr)
            addr_reg = self.register_allocator.get_reg_temp("addr")
            instructions.append(f"lw {addr_reg}, {offset}($fp)")
        else:
            addr_reg = self.register_allocator.get_reg_temp("addr")
            instructions.append(f"li {addr_reg}, {addr}")

        # Obtener el valor a almacenar DESPUÉS (to avoid overwriting addr_reg)
        if self._is_temporary(value):
            value_reg = self.register_allocator.get_reg(value)
        elif self._is_fp_relative(value):
            # value es algo como FP[4] o FP[8]: está relativo a $fp
            value_reg = None
            for reg in ['$t0', '$t1', '$t2', '$t3', '$t4', '$t5', '$t6', '$t7', '$t8', '$t9', '$at']:
                if reg != addr_reg:
                    value_reg = reg
                    break
            if not value_reg:
                value_reg = '$at'

            offset = self._extract_fp_offset(value)
            instructions.append(f"lw {value_reg}, {offset}($fp)  # Load from frame")
        elif self._is_immediate(value):
            # Use a different register than addr_reg
            value_reg = None
            for reg in ['$t0', '$t1', '$t2', '$t3', '$t4', '$t5', '$t6', '$t7', '$t8', '$t9', '$at']:
                if reg != addr_reg:
                    value_reg = reg
                    break
            if not value_reg:
                value_reg = '$at'
            normalized = self._normalize_value(value)
            instructions.append(f"li {value_reg}, {normalized}")
        else:
            # Cargar desde memoria
            value_reg = None
            for reg in ['$t0', '$t1', '$t2', '$t3', '$t4', '$t5', '$t6', '$t7', '$t8', '$t9', '$at']:
                if reg != addr_reg:
                    value_reg = reg
                    break
            if not value_reg:
                value_reg = '$at'
            var_label = self._get_memory_label(value)
            instructions.append(f"lw {value_reg}, {var_label}")

        # Almacenar el valor en la dirección
        instructions.append(f"sw {value_reg}, 0({addr_reg})  # Array store")

        return instructions

    def _translate_function_quad(self, quad):
        """
        Traduce cuádruplos de función: enter, call, push, pop, return, leave

        Quadruples:
        - (enter, size, None, None): Function prologue
        - (push, arg, None, None): Push argument for call
        - (call, None, None, func_label): Call function
        - (pop, None, None, result): Get return value
        - (return, value, None, None): Return from function
        - (leave, None, None, None): Function epilogue
        """
        instructions = []

        if quad.op == 'enter':
            # Function prologue: setup stack frame
            # On entry: $sp points to last pushed argument (first parameter)
            # TAC convention: FP[0] = first param, FP[4] = second param, etc.
            # So $fp must point to the first parameter location
            #
            # Stack layout after prologue:
            # [arg2]
            # [arg1]
            # [arg0] ← $fp points here (FP[0])
            # [$ra]  ← -4($fp)
            # [$fp]  ← -8($fp)
            # [locals] ← $sp points here

            frame_size = int(quad.arg1) if quad.arg1 else 0

            instructions.append(f"# Function prologue (locals: {frame_size} bytes)")

            # Save $ra and $fp BELOW current $sp (which points to arg0)
            instructions.append(f"sw $ra, -4($sp)")
            instructions.append(f"sw $fp, -8($sp)")

            # Set $fp to point to arg0 location (current $sp)
            instructions.append(f"move $fp, $sp")

            # Move $sp down past saved $ra/$fp and allocate locals
            total_offset = 8 + frame_size
            instructions.append(f"addiu $sp, $sp, -{total_offset}")

        elif quad.op == 'leave':
            # Function epilogue: cleanup stack frame
            # Current state: $fp points to arg0, $sp points below locals
            # Saved $fp is at -8($fp), saved $ra is at -4($fp)
            instructions.append(f"# Function epilogue")

            # Point $sp to saved $fp location
            instructions.append(f"addiu $sp, $fp, -8")

            # Restore $fp and $ra
            instructions.append(f"lw $fp, 0($sp)")
            instructions.append(f"lw $ra, 4($sp)")

            # Pop $fp/$ra from stack (sp now points to arg0 location)
            instructions.append(f"addiu $sp, $sp, 8")

            # Return to caller (caller will clean up arguments)
            instructions.append(f"jr $ra")

        elif quad.op == 'push':
            # Push argument onto stack for function call
            # Arguments are pushed in reverse order
            arg = quad.arg1

            instructions.append(f"# Push argument: {arg}")

            # Get register for argument
            arg_reg = self.register_allocator.get_reg_temp("push_arg")

            # Load argument value
            if self._is_temporary(arg):
                arg_reg = self.register_allocator.get_reg(arg)
            else:
                self._load_value_to_reg(arg, arg_reg, instructions)

            # Push onto stack
            instructions.append(f"addiu $sp, $sp, -4")
            instructions.append(f"sw {arg_reg}, 0($sp)")

            # Track for parameter passing to $a0-$a3 if needed
            self.param_registers.append(arg_reg)

        elif quad.op == 'call':
            # Call function
            instructions.append(f"# Call function: {quad.result}")

            call_instrs = self._translate_method_call(quad)
            if isinstance(call_instrs, str):
                instructions.append(call_instrs)
            else:
                instructions.extend(call_instrs)

            # Clear param register tracking
            self.param_registers.clear()

        elif quad.op == 'pop':
            # Pop return value from function call
            # Return value is in $v0
            result = quad.result

            instructions.append(f"# Get return value")

            if self._is_temporary(result):
                result_reg = self.register_allocator.get_reg(result)
                instructions.append(f"move {result_reg}, $v0")
            else:
                # Store return value to memory
                result_addr = self._get_memory_label(result)
                instructions.append(f"sw $v0, {result_addr}")

        elif quad.op == 'return':
            # Return from function with optional value
            return_value = quad.arg1

            instructions.append(f"# Return statement")

            if return_value is not None:
                # Load return value into $v0
                if self._is_temporary(return_value):
                    return_reg = self.register_allocator.get_reg(return_value)
                    instructions.append(f"move $v0, {return_reg}")
                else:
                    # Load from memory or immediate
                    temp_reg = self.register_allocator.get_reg_temp("return_temp")
                    self._load_value_to_reg(return_value, temp_reg, instructions)
                    instructions.append(f"move $v0, {temp_reg}")

            # Jump to function epilogue (leave will handle cleanup)
            # For now, we don't jump - leave quadruple follows immediately

        elif quad.op == 'add' and (quad.arg1 == 'SP' or str(quad.arg1).upper() == 'SP'):
            # Stack cleanup after function call: (add, SP, size, SP)
            # This adjusts SP after popping arguments
            cleanup_size = quad.arg2
            instructions.append(f"# Clean up arguments from stack ({cleanup_size} bytes)")
            instructions.append(f"addiu $sp, $sp, {cleanup_size}")

        return instructions

    def _is_temporary(self, value):
        """
        Verifica si un valor es un temporal (t0, t1, etc.)

        NOTA: Debido a un bug en el código intermedio, a veces 'true' o 'false'
        se usan como nombres de temporales. Por ahora, NO los consideramos temporales
        para forzar su conversión a valores numéricos.
        """
        if not isinstance(value, str):
            return False

        # No tratar 'true' o 'false' como temporales, incluso si el código intermedio los usa así
        if value in ['true', 'false']:
            return False

        return value.startswith('t') and value[1:].isdigit()

    def _is_fp_relative(self, value):
        """
        Verifica si un valor es una dirección relativa al frame pointer (FP[offset])
        """
        return isinstance(value, str) and value.startswith('FP[') and value.endswith(']')

    def _extract_fp_offset(self, fp_address):
        """
        Extrae el offset de una dirección FP-relative
        Ejemplo: "FP[8]" -> "8"
        """
        if self._is_fp_relative(fp_address):
            return fp_address[3:-1]  # Remove "FP[" and "]"
        return "0"

    def _sanitize_label(self, label):
        """
        Sanitiza etiquetas para que sean válidas en MIPS
        Convierte espacios y paréntesis a guiones bajos
        Ejemplo: "FUNC_add (Calculator)" -> "FUNC_add_Calculator"
        """
        if not isinstance(label, str):
            return str(label)
        # Replace spaces with underscores
        sanitized = label.replace(' ', '_')
        # Remove parentheses
        sanitized = sanitized.replace('(', '').replace(')', '')
        return sanitized

    def _is_immediate(self, value):
        """Verifica si un valor es un inmediato (número o booleano)"""
        if isinstance(value, (int, float)):
            return True
        if isinstance(value, str):
            # Verificar si es un booleano literal
            if value in ['true', 'false']:
                return True
            try:
                # Use base 0 to auto-detect hex (0x...), octal (0o...), etc.
                int(value, 0)
                return True
            except ValueError:
                return False
        return False

    def _normalize_value(self, value):
        """
        Normaliza un valor, convirtiendo booleanos literales a números

        Args:
            value: El valor a normalizar (puede ser 'true', 'false', número, etc.)

        Returns:
            El valor normalizado (true -> 1, false -> 0, otros sin cambio)
        """
        if isinstance(value, str):
            if value == 'true':
                return '1'
            elif value == 'false':
                return '0'
        return value

    def _load_value_to_reg(self, value, reg, instructions):
        """
        Helper para cargar un valor en un registro, manejando temporales, inmediatos y variables

        Args:
            value: El valor a cargar (puede ser temporal, inmediato, variable, etc.)
            reg: El registro destino
            instructions: Lista de instrucciones donde agregar el código

        Returns:
            None (modifica instructions in-place)
        """
        if self._is_temporary(value):
            # Si es temporal, ya está en registro (no hacer nada)
            pass
        elif self._is_fp_relative(value):
            # FP-relative addressing: FP[offset]
            offset = self._extract_fp_offset(value)
            instructions.append(f"lw {reg}, {offset}($fp)  # Load from frame")
        elif isinstance(value, str) and value.startswith('0x'):
            # Es una dirección de memoria - verificar si es un array
            try:
                addr_int = int(value, 16)
                if addr_int >= 0x8000:
                    # Es un array - cargar DIRECCIÓN (la), no valor (lw)
                    addr_label = self._get_memory_label(value)
                    instructions.append(f"la {reg}, {addr_label}  # Load array address")
                else:
                    # Es una variable regular - cargar valor
                    addr_label = self._get_memory_label(value)
                    instructions.append(f"lw {reg}, {addr_label}")
            except ValueError:
                # No es hex válido, tratar como variable
                addr = self._get_memory_label(value)
                instructions.append(f"lw {reg}, {addr}")
        elif self._is_immediate(value):
            # Es un inmediato (número o booleano)
            normalized = self._normalize_value(value)
            instructions.append(f"li {reg}, {normalized}")
        elif isinstance(value, str) and value.startswith('str_'):
            # Es una etiqueta de string literal - cargar DIRECCIÓN (la), no valor (lw)
            instructions.append(f"la {reg}, {value}  # Load string address")
        else:
            # Es una variable, cargar desde memoria
            addr = self._get_memory_label(value)
            instructions.append(f"lw {reg}, {addr}")

    def _get_memory_label(self, identifier):
        """
        Obtiene la etiqueta de memoria para un identificador

        Args:
            identifier: Puede ser un nombre de variable o una dirección hexadecimal

        Returns:
            String con la etiqueta MIPS (ej: "var_a" o "0x1000")
        """
        # Si es una dirección hexadecimal
        if isinstance(identifier, str) and identifier.startswith('0x'):
            # Buscar la variable correspondiente
            try:
                addr = int(identifier, 16)
                for var_name, var_addr in self.memory_manager.allocations.items():
                    if var_addr == addr:
                        return f"var_{var_name}"
                # Si no se encuentra, usar la dirección directamente
                return identifier
            except ValueError:
                pass

        # Si es un nombre de variable
        if identifier in self.memory_manager.allocations:
            return f"var_{identifier}"

        # Si no se encuentra, asumir que es una etiqueta válida
        return str(identifier)

    def _assemble_final_code(self):
        """Ensambla todas las secciones en un programa MIPS completo"""
        lines = []

        # Encabezado
        lines.append("# Generated by Compiscript Compiler")
        lines.append("# MIPS Assembly Code")
        lines.append("")

        # Sección de datos
        lines.extend(self.data_section)
        lines.append("")

        # Sección de texto
        lines.extend(self.text_section)
        lines.append("")

        # String runtime functions
        lines.extend(self._generate_string_runtime_functions())
        lines.append("")

        return "\n".join(lines)

    def _generate_string_runtime_functions(self):
        """Generate runtime helper functions for string operations"""
        lines = []
        lines.append("# ===== String Runtime Functions =====")
        lines.append("")

        # __string_copy: Copy null-terminated string from src to dest
        # Args: $a0 = dest, $a1 = src
        # Returns: nothing
        lines.append("__string_copy:")
        lines.append("    # Save registers")
        lines.append("    addiu $sp, $sp, -8")
        lines.append("    sw $t0, 0($sp)")
        lines.append("    sw $t1, 4($sp)")
        lines.append("")
        lines.append("__string_copy_loop:")
        lines.append("    lb $t0, 0($a1)      # Load byte from src")
        lines.append("    sb $t0, 0($a0)      # Store byte to dest")
        lines.append("    beq $t0, $zero, __string_copy_done  # If null terminator, done")
        lines.append("    addiu $a0, $a0, 1   # dest++")
        lines.append("    addiu $a1, $a1, 1   # src++")
        lines.append("    j __string_copy_loop")
        lines.append("")
        lines.append("__string_copy_done:")
        lines.append("    # Restore registers")
        lines.append("    lw $t0, 0($sp)")
        lines.append("    lw $t1, 4($sp)")
        lines.append("    addiu $sp, $sp, 8")
        lines.append("    jr $ra")
        lines.append("")

        # __string_length: Calculate length of null-terminated string
        # Args: $a0 = string address
        # Returns: $v0 = length
        lines.append("__string_length:")
        lines.append("    # Save registers")
        lines.append("    addiu $sp, $sp, -4")
        lines.append("    sw $t0, 0($sp)")
        lines.append("")
        lines.append("    li $v0, 0           # length = 0")
        lines.append("__string_length_loop:")
        lines.append("    lb $t0, 0($a0)      # Load byte")
        lines.append("    beq $t0, $zero, __string_length_done  # If null, done")
        lines.append("    addiu $v0, $v0, 1   # length++")
        lines.append("    addiu $a0, $a0, 1   # str++")
        lines.append("    j __string_length_loop")
        lines.append("")
        lines.append("__string_length_done:")
        lines.append("    # Restore registers")
        lines.append("    lw $t0, 0($sp)")
        lines.append("    addiu $sp, $sp, 4")
        lines.append("    jr $ra")
        lines.append("")

        # __string_compare: Compare two null-terminated strings
        # Args: $a0 = str1, $a1 = str2
        # Returns: $v0 = 1 if equal, 0 if not equal
        lines.append("__string_compare:")
        lines.append("    # Save registers")
        lines.append("    addiu $sp, $sp, -8")
        lines.append("    sw $t0, 0($sp)")
        lines.append("    sw $t1, 4($sp)")
        lines.append("")
        lines.append("__string_compare_loop:")
        lines.append("    lb $t0, 0($a0)      # Load byte from str1")
        lines.append("    lb $t1, 0($a1)      # Load byte from str2")
        lines.append("    bne $t0, $t1, __string_compare_not_equal  # If different, not equal")
        lines.append("    beq $t0, $zero, __string_compare_equal  # If both null, equal")
        lines.append("    addiu $a0, $a0, 1   # str1++")
        lines.append("    addiu $a1, $a1, 1   # str2++")
        lines.append("    j __string_compare_loop")
        lines.append("")
        lines.append("__string_compare_equal:")
        lines.append("    li $v0, 1           # Return 1 (equal)")
        lines.append("    j __string_compare_done")
        lines.append("")
        lines.append("__string_compare_not_equal:")
        lines.append("    li $v0, 0           # Return 0 (not equal)")
        lines.append("")
        lines.append("__string_compare_done:")
        lines.append("    # Restore registers")
        lines.append("    lw $t0, 0($sp)")
        lines.append("    lw $t1, 4($sp)")
        lines.append("    addiu $sp, $sp, 8")
        lines.append("    jr $ra")
        lines.append("")

        return lines

    def _is_string_variable(self, operand):
        """
        Check if an operand represents a string variable by looking up its type in the symbol table.
        """
        # String literal label
        if isinstance(operand, str) and operand.startswith('str_'):
            return True

        # Memory address - check memory manager and symbol table
        if isinstance(operand, str) and operand.startswith('0x'):
            addr = int(operand, 16)

            # Find variable name from memory allocations
            var_name = None
            for name, allocated_addr in self.memory_manager.allocations.items():
                if allocated_addr == addr:
                    var_name = name
                    break

            if var_name:
                # Look up type in symbol table
                for scope in self.symbol_table.all_scopes:
                    if var_name in scope.symbols:
                        symbol = scope.symbols[var_name]
                        if hasattr(symbol, 'type') and symbol.type is not None:
                            type_name = symbol.type.name if hasattr(symbol.type, 'name') else str(symbol.type)
                            if type_name == 'string':
                                return True

        return False

    def _might_be_string_comparison(self, arg1, arg2):
        """
        Heurística para detectar si esta es una comparación de strings.
        Usa información de la tabla de símbolos para determinar tipos.
        """
        # Check if either operand is a string variable or literal
        if self._is_string_variable(arg1) or self._is_string_variable(arg2):
            return True

        return False

    def _might_be_string_concat(self, arg1, arg2):
        """
        Heurística para detectar si esta es una concatenación de strings.
        Uses symbol table lookup to verify types.
        """
        # Strong evidence: at least one operand is a string literal label
        if isinstance(arg1, str) and arg1.startswith('str_'):
            return True
        if isinstance(arg2, str) and arg2.startswith('str_'):
            return True

        # Check if both operands are string variables using type information
        # This prevents false positives with integer arithmetic
        if self._is_string_variable(arg1) and self._is_string_variable(arg2):
            return True
        if self._is_string_variable(arg1) or self._is_string_variable(arg2):
            # At least one is a string variable
            # If the other is a temporary or address, check if it's also a string
            if self._is_string_variable(arg1):
                return self._is_string_variable(arg2) or (isinstance(arg2, str) and arg2.startswith('t'))
            else:
                return self._is_string_variable(arg1) or (isinstance(arg1, str) and arg1.startswith('t'))

        return False

    def _translate_string_concat(self, quad):
        """
        Traduce concatenación de strings: (+ str1, str2, result)

        Strategy: Use a runtime buffer and inline string copy code
        """
        instructions = []
        instructions.append("# String concatenation")

        arg1 = quad.arg1
        arg2 = quad.arg2
        result = quad.result

        # Use specific temp registers to avoid conflicts
        str1_reg = '$s1'  # Use saved registers to preserve across calls
        str2_reg = '$s2'
        result_reg = self.register_allocator.get_reg(result)

        # Save $s1 and $s2 if needed
        instructions.append("addiu $sp, $sp, -8")
        instructions.append("sw $s1, 0($sp)")
        instructions.append("sw $s2, 4($sp)")

        # Load addresses of both strings
        self._load_string_address(arg1, str1_reg, instructions)
        self._load_string_address(arg2, str2_reg, instructions)

        # Load buffer address into result register
        instructions.append(f"la {result_reg}, string_concat_buffer  # Load buffer address")

        # Copy str1 to buffer
        instructions.append(f"move $a0, {result_reg}  # dest = buffer")
        instructions.append(f"move $a1, {str1_reg}  # src = str1")
        instructions.append("jal __string_copy")

        # Find end of buffer (after str1)
        instructions.append(f"la $a0, string_concat_buffer")
        instructions.append("jal __string_length")
        instructions.append(f"la {result_reg}, string_concat_buffer")
        instructions.append(f"add $a0, {result_reg}, $v0  # Move to end of str1")

        # Copy str2 after str1
        instructions.append(f"move $a1, {str2_reg}  # src = str2")
        instructions.append("jal __string_copy")

        # Reset result to buffer start
        instructions.append(f"la {result_reg}, string_concat_buffer")

        # Restore $s1 and $s2
        instructions.append("lw $s1, 0($sp)")
        instructions.append("lw $s2, 4($sp)")
        instructions.append("addiu $sp, $sp, 8")

        return instructions

    def _translate_string_comparison(self, quad):
        """
        Traduce comparación de strings: (==, str1, str2, result) or (!=, str1, str2, result)
        """
        instructions = []
        instructions.append("# String comparison")

        arg1 = quad.arg1
        arg2 = quad.arg2
        result = quad.result

        # Use saved registers
        str1_reg = '$s1'
        str2_reg = '$s2'
        result_reg = self.register_allocator.get_reg(result)

        # Save $s1 and $s2
        instructions.append("addiu $sp, $sp, -8")
        instructions.append("sw $s1, 0($sp)")
        instructions.append("sw $s2, 4($sp)")

        # Load string addresses
        self._load_string_address(arg1, str1_reg, instructions)
        self._load_string_address(arg2, str2_reg, instructions)

        # Call string compare function
        instructions.append(f"move $a0, {str1_reg}")
        instructions.append(f"move $a1, {str2_reg}")
        instructions.append("jal __string_compare")

        # $v0 now contains 1 if equal, 0 if not equal
        if quad.op == '==':
            # Return the result as-is
            instructions.append(f"move {result_reg}, $v0")
        else:  # !=
            # Invert the result
            instructions.append(f"xori {result_reg}, $v0, 1")

        # Restore $s1 and $s2
        instructions.append("lw $s1, 0($sp)")
        instructions.append("lw $s2, 4($sp)")
        instructions.append("addiu $sp, $sp, 8")

        return instructions

    def _load_string_address(self, value, reg, instructions):
        """Helper to load a string address into a register"""
        if isinstance(value, str) and value.startswith('str_'):
            # String literal label
            instructions.append(f"la {reg}, {value}")
        elif isinstance(value, str) and value.startswith('0x'):
            # Memory address - load the address stored there
            label = self._get_memory_label(value)
            instructions.append(f"lw {reg}, {label}")
        elif self._is_temporary(value):
            # Already in a register
            temp_reg = self.register_allocator.get_reg(value)
            if temp_reg != reg:
                instructions.append(f"move {reg}, {temp_reg}")
        else:
            # Fallback
            instructions.append(f"li {reg}, 0  # Unknown string source")

    def save_to_file(self, filename):
        """Guarda el código MIPS en un archivo .asm"""
        code = self.generate_mips_code()
        with open(filename, 'w') as f:
            f.write(code)
        return filename

    # --- Objetos y métodos (Etapa 3) ---

    def _is_object_address_quad(self, quad) -> bool:
        """
        Detecta cuádruplos que calculan la dirección de un atributo de objeto.
        Patrón en TAC: (+, <baseTemp>, <offset>, <resultTemp>) con comment que incluye 'Address of'.
        """
        try:
            return quad.op == '+' and quad.comment and ('Address of' in str(quad.comment))
        except AttributeError:
            return False

    def _translate_object_access(self, quad):
        """
        Traduce: result = base + offset   (dirección efectiva de un atributo de objeto)
        Emite:   addiu result_reg, base_reg, <offset>
        """
        # arg1: temporal con la base (puntero a la instancia)
        base_reg = self.register_allocator.get_reg(quad.arg1)
        # result: temporal destino para la dirección resultante
        result_reg = self.register_allocator.get_reg(quad.result)

        # offset inmediato (ej. 8 para Estudiante.edad)
        offset_imm = str(quad.arg2)

        instr = []
        if getattr(quad, "comment", None):
            instr.append(f"# {quad.comment}")
        instr.append(f"addiu {result_reg}, {base_reg}, {offset_imm}")
        return instr

    def _translate_method_call(self, quad):
        """
        Traduce llamadas a métodos:
        TAC: (call, None, None, FUNC_<...>)
        MIPS: jal <label>
        """
        label = self._sanitize_label(quad.result)
        return [f"jal {label}"]

