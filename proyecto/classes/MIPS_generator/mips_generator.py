# classes/MIPS_generator/mips_generator.py
"""
MIPSGenerator - Generador principal de código MIPS desde cuádruplos TAC
"""

from .register_allocator import RegisterAllocator
from .mips_stack_manager import MIPSStackManager
from .mips_runtime import MIPSRuntime

class MIPSGenerator:
    def __init__(self, code_generator, symbol_table):
        """
        Inicializa el generador de MIPS

        Args:
            code_generator: El CodeGenerator que contiene los cuádruplos
            symbol_table: La tabla de símbolos del programa
        """
        self.cg = code_generator
        self.symbol_table = symbol_table
        self.memory_manager = code_generator.memory_manager
        self.register_allocator = RegisterAllocator()
        self.stack_manager = MIPSStackManager()
        self.runtime = MIPSRuntime()

        # Instrucciones MIPS generadas
        self.data_section = []
        self.text_section = []

    def generate_mips_code(self):
        """Genera código MIPS completo desde los cuádruplos"""
        # 1. Sección de datos (variables globales)
        self._generate_data_section()

        # 2. Sección de texto (código ejecutable)
        self._generate_text_section()

        # 3. Ensamblar archivo final
        return self._assemble_final_code()

    def _generate_data_section(self):
        """Genera la sección .data con variables globales"""
        self.data_section.append("# Generated by Compiscript Compiler")
        self.data_section.append(".data")

        # Obtener todas las variables globales del memory manager
        global_vars = {name: addr for name, addr in self.memory_manager.allocations.items()
                      if isinstance(addr, int) and addr >= 0x1000 and addr < 0x8000}

        # Ordenar por dirección
        sorted_vars = sorted(global_vars.items(), key=lambda x: x[1])

        for var_name, address in sorted_vars:
            # Generar etiqueta para cada variable
            self.data_section.append(f"var_{var_name}: .word 0  # Address: {hex(address)}")

        self.data_section.append("")

    def _generate_text_section(self):
        """Genera la sección .text con el código principal"""
        self.text_section.append(".text")
        self.text_section.append(".globl main")
        self.text_section.append("")
        self.text_section.append("main:")

        # Prólogo del main
        self.text_section.append("    # Main prologue")
        self.text_section.append("    addiu $sp, $sp, -4")
        self.text_section.append("    sw $ra, 0($sp)")
        self.text_section.append("")

        # Traducir cada cuádruplo
        for idx, quad in enumerate(self.cg.quadruples):
            self.text_section.append(f"    # Quadruple {idx}: {quad}")
            instructions = self._translate_quadruple(quad)
            for instruction in instructions:
                if instruction.strip():  # Solo agregar líneas no vacías
                    self.text_section.append(f"    {instruction}")
            self.text_section.append("")

        # Epílogo del main
        self.text_section.append("    # Main epilogue")
        self.text_section.append("    lw $ra, 0($sp)")
        self.text_section.append("    addiu $sp, $sp, 4")
        self.text_section.append("    li $v0, 10  # Exit syscall")
        self.text_section.append("    syscall")

    def _translate_quadruple(self, quad):
        """
        Traduce un cuádruplo individual a instrucciones MIPS

        Args:
            quad: El cuádruplo a traducir

        Returns:
            Lista de instrucciones MIPS
        """
        op = quad.op

        # Operaciones aritméticas
        if op in ['+', '-', '*', '/']:
            return self._translate_arithmetic_quad(quad)

        # Operaciones de asignación
        elif op == '=':
            return self._translate_assignment_quad(quad)

        # Operaciones de carga (@)
        elif op == '@':
            return self._translate_load_quad(quad)

        # Operaciones de comparación
        elif op in ['<', '>', '<=', '>=', '==', '!=']:
            return self._translate_comparison_quad(quad)

        # Operaciones de salto
        elif op in ['goto', 'if', 'if_false', 'ifFalse']:
            return self._translate_jump_quad(quad)

        # Operaciones de función
        elif op in ['call', 'param', 'return']:
            return self._translate_function_quad(quad)

        # Operación de etiqueta
        elif op == 'label':
            return self._translate_label_quad(quad)

        else:
            return [f"# TODO: Translate operation '{op}'"]

    def _translate_arithmetic_quad(self, quad):
        """
        Traduce cuádruplos aritméticos: (op, arg1, arg2, result)
        Ejemplo: (+, t0, t1, t2) -> add $t2, $t0, $t1
        """
        instructions = []

        # Mapeo de operadores TAC a MIPS
        mips_ops = {
            '+': 'add',
            '-': 'sub',
            '*': 'mul',
            '/': 'div'
        }

        mips_op = mips_ops.get(quad.op)
        if not mips_op:
            return [f"# ERROR: Unknown arithmetic operation '{quad.op}'"]

        # Obtener registros para los operandos
        arg1_reg = self.register_allocator.get_reg(quad.arg1)
        arg2_reg = self.register_allocator.get_reg(quad.arg2)
        result_reg = self.register_allocator.get_reg(quad.result)

        # Cargar arg1
        if self._is_temporary(quad.arg1):
            # Si es temporal, ya debería estar en registro
            pass
        elif self._is_immediate(quad.arg1):
            instructions.append(f"li {arg1_reg}, {quad.arg1}")
        else:
            # Es una variable, cargar desde memoria
            addr = self._get_memory_label(quad.arg1)
            instructions.append(f"lw {arg1_reg}, {addr}")

        # Cargar arg2
        if self._is_temporary(quad.arg2):
            # Si es temporal, ya debería estar en registro
            pass
        elif self._is_immediate(quad.arg2):
            instructions.append(f"li {arg2_reg}, {quad.arg2}")
        else:
            # Es una variable, cargar desde memoria
            addr = self._get_memory_label(quad.arg2)
            instructions.append(f"lw {arg2_reg}, {addr}")

        # Realizar la operación
        if quad.op == '/':
            # División es especial en MIPS
            instructions.append(f"div {arg1_reg}, {arg2_reg}")
            instructions.append(f"mflo {result_reg}  # quotient")
        else:
            instructions.append(f"{mips_op} {result_reg}, {arg1_reg}, {arg2_reg}")

        return instructions

    def _translate_assignment_quad(self, quad):
        """
        Traduce cuádruplos de asignación: (=, value, None, target)
        Ejemplo: (=, 5, None, 0x1000) -> li $t0, 5; sw $t0, var_a
        """
        instructions = []

        value = quad.arg1
        target = quad.result

        # Obtener registro para el valor
        value_reg = self.register_allocator.get_reg_temp("assign_temp")

        # Cargar el valor
        if self._is_temporary(value):
            # Si es temporal, obtener su registro
            value_reg = self.register_allocator.get_reg(value)
        elif self._is_immediate(value):
            instructions.append(f"li {value_reg}, {value}")
        else:
            # Es una variable, cargar desde memoria
            addr = self._get_memory_label(value)
            instructions.append(f"lw {value_reg}, {addr}")

        # Guardar en el target
        if self._is_temporary(target):
            # Si target es temporal, mover a su registro
            target_reg = self.register_allocator.get_reg(target)
            if value_reg != target_reg:
                instructions.append(f"move {target_reg}, {value_reg}")
        else:
            # Es una variable o dirección, guardar en memoria
            target_addr = self._get_memory_label(target)
            instructions.append(f"sw {value_reg}, {target_addr}")

        return instructions

    def _translate_load_quad(self, quad):
        """
        Traduce cuádruplos de carga: (@, addr, None, temp)
        Ejemplo: (@, 0x1000, None, t0) -> lw $t0, var_a
        """
        instructions = []

        addr = quad.arg1
        target_temp = quad.result

        # Obtener registro para el temporal
        target_reg = self.register_allocator.get_reg(target_temp)

        # Cargar desde memoria
        source_addr = self._get_memory_label(addr)
        instructions.append(f"lw {target_reg}, {source_addr}")

        return instructions

    def _translate_comparison_quad(self, quad):
        """
        Traduce cuádruplos de comparación: (op, arg1, arg2, result)
        Ejemplo: (<, t0, t1, t2) -> slt $t2, $t0, $t1

        En MIPS, las comparaciones usan:
        - slt (set less than): result = 1 si arg1 < arg2, 0 si no
        - seq (set equal): result = 1 si arg1 == arg2, 0 si no
        - sne (set not equal): result = 1 si arg1 != arg2, 0 si no
        - Para <=, >, >= usamos combinaciones
        """
        instructions = []

        # Obtener registros para los operandos
        arg1_reg = self.register_allocator.get_reg(quad.arg1)
        arg2_reg = self.register_allocator.get_reg(quad.arg2)
        result_reg = self.register_allocator.get_reg(quad.result)

        # Cargar arg1
        if self._is_temporary(quad.arg1):
            # Si es temporal, ya debería estar en registro
            pass
        elif self._is_immediate(quad.arg1):
            instructions.append(f"li {arg1_reg}, {quad.arg1}")
        else:
            # Es una variable, cargar desde memoria
            addr = self._get_memory_label(quad.arg1)
            instructions.append(f"lw {arg1_reg}, {addr}")

        # Cargar arg2
        if self._is_temporary(quad.arg2):
            # Si es temporal, ya debería estar en registro
            pass
        elif self._is_immediate(quad.arg2):
            instructions.append(f"li {arg2_reg}, {quad.arg2}")
        else:
            # Es una variable, cargar desde memoria
            addr = self._get_memory_label(quad.arg2)
            instructions.append(f"lw {arg2_reg}, {addr}")

        # Realizar la comparación
        if quad.op == '<':
            # slt: set less than
            instructions.append(f"slt {result_reg}, {arg1_reg}, {arg2_reg}")

        elif quad.op == '<=':
            # <= es equivalente a: NOT (arg1 > arg2)
            # arg1 <= arg2 es lo mismo que arg2 >= arg1
            # Usamos: slt $temp, arg2, arg1; xori result, $temp, 1
            temp_reg = self.register_allocator.get_reg_temp("cmp_temp")
            instructions.append(f"slt {temp_reg}, {arg2_reg}, {arg1_reg}")  # temp = arg2 < arg1
            instructions.append(f"xori {result_reg}, {temp_reg}, 1")  # result = NOT temp

        elif quad.op == '>':
            # > es lo mismo que arg2 < arg1
            instructions.append(f"slt {result_reg}, {arg2_reg}, {arg1_reg}")

        elif quad.op == '>=':
            # >= es equivalente a: NOT (arg1 < arg2)
            temp_reg = self.register_allocator.get_reg_temp("cmp_temp")
            instructions.append(f"slt {temp_reg}, {arg1_reg}, {arg2_reg}")  # temp = arg1 < arg2
            instructions.append(f"xori {result_reg}, {temp_reg}, 1")  # result = NOT temp

        elif quad.op == '==':
            # == : xor + seq (set equal to zero)
            # Si arg1 == arg2, entonces arg1 XOR arg2 = 0
            instructions.append(f"xor {result_reg}, {arg1_reg}, {arg2_reg}")
            instructions.append(f"sltiu {result_reg}, {result_reg}, 1")  # result = (result == 0)

        elif quad.op == '!=':
            # != : xor + sne (set not equal to zero)
            # Si arg1 != arg2, entonces arg1 XOR arg2 != 0
            instructions.append(f"xor {result_reg}, {arg1_reg}, {arg2_reg}")
            instructions.append(f"sltu {result_reg}, $zero, {result_reg}")  # result = (result != 0)

        return instructions

    def _translate_jump_quad(self, quad):
        """
        Traduce cuádruplos de salto y control de flujo

        Tipos de saltos:
        - goto: Salto incondicional
        - if: Salto si la condición es verdadera (!=0)
        - if_false/ifFalse: Salto si la condición es falsa (==0)
        """
        instructions = []

        if quad.op == 'goto':
            # Salto incondicional: (goto, None, None, label)
            label = quad.result
            instructions.append(f"j {label}")

        elif quad.op in ['if', 'if_true']:
            # Salto condicional si verdadero: (if, condition, None, label)
            # En MIPS: bne condition, $zero, label (branch if not equal to zero)
            condition = quad.arg1
            label = quad.result

            # Obtener registro de la condición
            cond_reg = self.register_allocator.get_reg(condition)

            # Cargar condición si es necesario
            if self._is_temporary(condition):
                # Ya está en registro
                pass
            elif self._is_immediate(condition):
                instructions.append(f"li {cond_reg}, {condition}")
            else:
                # Es una variable
                addr = self._get_memory_label(condition)
                instructions.append(f"lw {cond_reg}, {addr}")

            # Branch if not equal to zero (si es verdadero)
            instructions.append(f"bne {cond_reg}, $zero, {label}")

        elif quad.op in ['if_false', 'ifFalse']:
            # Salto condicional si falso: (if_false, condition, None, label)
            # En MIPS: beq condition, $zero, label (branch if equal to zero)
            condition = quad.arg1
            label = quad.result

            # Obtener registro de la condición
            cond_reg = self.register_allocator.get_reg(condition)

            # Cargar condición si es necesario
            if self._is_temporary(condition):
                # Ya está en registro
                pass
            elif self._is_immediate(condition):
                instructions.append(f"li {cond_reg}, {condition}")
            else:
                # Es una variable
                addr = self._get_memory_label(condition)
                instructions.append(f"lw {cond_reg}, {addr}")

            # Branch if equal to zero (si es falso)
            instructions.append(f"beq {cond_reg}, $zero, {label}")

        return instructions

    def _translate_label_quad(self, quad):
        """
        Traduce cuádruplos de etiqueta: (label, None, None, L0)
        Simplemente genera la etiqueta en MIPS
        """
        label_name = quad.result
        return [f"{label_name}:"]

    def _translate_function_quad(self, quad):
        """Traduce cuádruplos de función (por implementar)"""
        return [f"# TODO: Translate function operation '{quad.op}'"]

    def _is_temporary(self, value):
        """Verifica si un valor es un temporal (t0, t1, etc.)"""
        return isinstance(value, str) and value.startswith('t') and value[1:].isdigit()

    def _is_immediate(self, value):
        """Verifica si un valor es un inmediato (número)"""
        if isinstance(value, (int, float)):
            return True
        if isinstance(value, str):
            try:
                int(value)
                return True
            except ValueError:
                return False
        return False

    def _get_memory_label(self, identifier):
        """
        Obtiene la etiqueta de memoria para un identificador

        Args:
            identifier: Puede ser un nombre de variable o una dirección hexadecimal

        Returns:
            String con la etiqueta MIPS (ej: "var_a" o "0x1000")
        """
        # Si es una dirección hexadecimal
        if isinstance(identifier, str) and identifier.startswith('0x'):
            # Buscar la variable correspondiente
            try:
                addr = int(identifier, 16)
                for var_name, var_addr in self.memory_manager.allocations.items():
                    if var_addr == addr:
                        return f"var_{var_name}"
                # Si no se encuentra, usar la dirección directamente
                return identifier
            except ValueError:
                pass

        # Si es un nombre de variable
        if identifier in self.memory_manager.allocations:
            return f"var_{identifier}"

        # Si no se encuentra, asumir que es una etiqueta válida
        return str(identifier)

    def _assemble_final_code(self):
        """Ensambla todas las secciones en un programa MIPS completo"""
        lines = []

        # Encabezado
        lines.append("# Generated by Compiscript Compiler")
        lines.append("# MIPS Assembly Code")
        lines.append("")

        # Sección de datos
        lines.extend(self.data_section)
        lines.append("")

        # Sección de texto
        lines.extend(self.text_section)
        lines.append("")

        # Funciones de runtime (futuro)
        # lines.extend(self.runtime.get_runtime_functions())

        return "\n".join(lines)

    def save_to_file(self, filename):
        """Guarda el código MIPS en un archivo .asm"""
        code = self.generate_mips_code()
        with open(filename, 'w') as f:
            f.write(code)
        return filename
