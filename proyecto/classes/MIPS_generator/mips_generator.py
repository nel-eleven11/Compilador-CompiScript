# classes/MIPS_generator/mips_generator.py
"""
MIPSGenerator - Generador principal de código MIPS desde cuádruplos TAC
"""

from .register_allocator import RegisterAllocator
from .mips_stack_manager import MIPSStackManager
from .mips_runtime import MIPSRuntime

class MIPSGenerator:
    def __init__(self, code_generator, symbol_table):
        """
        Inicializa el generador de MIPS

        Args:
            code_generator: El CodeGenerator que contiene los cuádruplos
            symbol_table: La tabla de símbolos del programa
        """
        self.cg = code_generator
        self.symbol_table = symbol_table
        self.memory_manager = code_generator.memory_manager
        self.register_allocator = RegisterAllocator()
        self.stack_manager = MIPSStackManager()
        self.runtime = MIPSRuntime()

        # Instrucciones MIPS generadas
        self.data_section = []
        self.text_section = []

        # Contexto de función actual durante la traducción
        self.current_function = None
        self.param_registers = []  # Para rastrear argumentos durante llamadas

    def generate_mips_code(self):
        """Genera código MIPS completo desde los cuádruplos"""
        # 1. Sección de datos (variables globales)
        self._generate_data_section()

        # 2. Sección de texto (código ejecutable)
        self._generate_text_section()

        # 3. Ensamblar archivo final
        return self._assemble_final_code()

    def _generate_data_section(self):
        """Genera la sección .data con variables globales"""
        self.data_section.append("# Generated by Compiscript Compiler")
        self.data_section.append(".data")

        # Obtener todas las variables globales del memory manager
        global_vars = {name: addr for name, addr in self.memory_manager.allocations.items()
                      if isinstance(addr, int) and addr >= 0x1000 and addr < 0x8000}

        # Ordenar por dirección
        sorted_vars = sorted(global_vars.items(), key=lambda x: x[1])

        for var_name, address in sorted_vars:
            # Generar etiqueta para cada variable
            self.data_section.append(f"var_{var_name}: .word 0  # Address: {hex(address)}")

        self.data_section.append("")

    def _generate_text_section(self):
        """Genera la sección .text con el código principal"""
        self.text_section.append(".text")
        self.text_section.append(".globl main")
        self.text_section.append("")

        # CRITICAL: Jump to main at the start to skip function definitions
        self.text_section.append("j main")
        self.text_section.append("")

        # Separate function quadruples from main quadruples
        function_quads = []
        main_quads = []
        current_function = None
        in_function = False

        for idx, quad in enumerate(self.cg.quadruples):
            # Check if this is a function label (starts with FUNC_)
            if quad.op == 'label' and isinstance(quad.result, str) and quad.result.startswith('FUNC_'):
                in_function = True
                current_function = []
                function_quads.append((idx, current_function))

            if in_function:
                current_function.append((idx, quad))
                # Check if function ends with 'leave'
                if quad.op == 'leave':
                    in_function = False
                    current_function = None
            else:
                main_quads.append((idx, quad))

        # Generate all functions first
        for func_idx, func_quads in function_quads:
            for idx, quad in func_quads:
                self.text_section.append(f"# Quadruple {idx}: {quad}")
                instructions = self._translate_quadruple(quad)
                for instruction in instructions:
                    if instruction.strip():
                        # Function labels should not be indented
                        if instruction.strip().endswith(':') and not instruction.strip().startswith('L'):
                            self.text_section.append(instruction.strip())
                        else:
                            self.text_section.append(f"    {instruction}")
                self.text_section.append("")

        # Generate main section
        self.text_section.append("main:")
        self.text_section.append("    # Main prologue")
        self.text_section.append("    addiu $sp, $sp, -4")
        self.text_section.append("    sw $ra, 0($sp)")
        self.text_section.append("")

        # Traducir cuádruplos del main
        for idx, quad in main_quads:
            self.text_section.append(f"    # Quadruple {idx}: {quad}")
            instructions = self._translate_quadruple(quad)
            for instruction in instructions:
                if instruction.strip():
                    self.text_section.append(f"    {instruction}")
            self.text_section.append("")

        # Epílogo del main
        self.text_section.append("    # Main epilogue")
        self.text_section.append("    lw $ra, 0($sp)")
        self.text_section.append("    addiu $sp, $sp, 4")
        self.text_section.append("    li $v0, 10  # Exit syscall")
        self.text_section.append("    syscall")

    def _translate_quadruple(self, quad):
        """
        Traduce un cuádruplo individual a instrucciones MIPS

        Args:
            quad: El cuádruplo a traducir

        Returns:
            Lista de instrucciones MIPS
        """
        op = quad.op

        # Operaciones aritméticas (including special stack operations)
        if op == '+' or op == 'add':
            # Check if this is stack cleanup: (add, SP, size, SP)
            if (quad.arg1 == 'SP' or str(quad.arg1).upper() == 'SP') and (quad.result == 'SP' or str(quad.result).upper() == 'SP'):
                return self._translate_function_quad(quad)
            elif op == '+':
                return self._translate_arithmetic_quad(quad)
            else:
                # 'add' without SP is still a function-related operation
                return self._translate_function_quad(quad)
        elif op in ['-', '*', '/']:
            return self._translate_arithmetic_quad(quad)

        # Operaciones de asignación
        elif op == '=':
            return self._translate_assignment_quad(quad)

        # Operaciones de carga (@)
        elif op == '@':
            return self._translate_load_quad(quad)

        # Operaciones de comparación
        elif op in ['<', '>', '<=', '>=', '==', '!=']:
            return self._translate_comparison_quad(quad)

        # Operaciones lógicas
        elif op in ['&&', '||', '!']:
            return self._translate_logical_quad(quad)

        # Operaciones unarias
        elif op in ['-', 'NEG'] and quad.arg2 is None:
            return self._translate_unary_quad(quad)

        # Operación de módulo
        elif op == '%':
            return self._translate_modulo_quad(quad)

        # Operaciones de salto
        elif op in ['goto', 'if', 'if_false', 'ifFalse']:
            return self._translate_jump_quad(quad)

        # Operaciones de función
        elif op in ['call', 'param', 'return', 'enter', 'leave', 'push', 'pop']:
            return self._translate_function_quad(quad)

        # Operación de etiqueta
        elif op == 'label':
            return self._translate_label_quad(quad)

        else:
            return [f"# TODO: Translate operation '{op}'"]

    def _translate_arithmetic_quad(self, quad):
        """
        Traduce cuádruplos aritméticos: (op, arg1, arg2, result)
        Ejemplo: (+, t0, t1, t2) -> add $t2, $t0, $t1
        """
        instructions = []

        # Mapeo de operadores TAC a MIPS
        mips_ops = {
            '+': 'add',
            '-': 'sub',
            '*': 'mul',
            '/': 'div'
        }

        mips_op = mips_ops.get(quad.op)
        if not mips_op:
            return [f"# ERROR: Unknown arithmetic operation '{quad.op}'"]

        # Obtener registros para los operandos
        arg1_reg = self.register_allocator.get_reg(quad.arg1)
        arg2_reg = self.register_allocator.get_reg(quad.arg2)
        result_reg = self.register_allocator.get_reg(quad.result)

        # Cargar arg1
        if self._is_temporary(quad.arg1):
            # Si es temporal, ya debería estar en registro
            pass
        elif self._is_fp_relative(quad.arg1):
            # FP-relative addressing: FP[offset]
            offset = self._extract_fp_offset(quad.arg1)
            instructions.append(f"lw {arg1_reg}, {offset}($fp)  # Load from frame")
        elif self._is_immediate(quad.arg1):
            instructions.append(f"li {arg1_reg}, {quad.arg1}")
        else:
            # Es una variable, cargar desde memoria
            addr = self._get_memory_label(quad.arg1)
            instructions.append(f"lw {arg1_reg}, {addr}")

        # Cargar arg2
        if self._is_temporary(quad.arg2):
            # Si es temporal, ya debería estar en registro
            pass
        elif self._is_fp_relative(quad.arg2):
            # FP-relative addressing: FP[offset]
            offset = self._extract_fp_offset(quad.arg2)
            instructions.append(f"lw {arg2_reg}, {offset}($fp)  # Load from frame")
        elif self._is_immediate(quad.arg2):
            instructions.append(f"li {arg2_reg}, {quad.arg2}")
        else:
            # Es una variable, cargar desde memoria
            addr = self._get_memory_label(quad.arg2)
            instructions.append(f"lw {arg2_reg}, {addr}")

        # Realizar la operación
        if quad.op == '/':
            # División es especial en MIPS
            instructions.append(f"div {arg1_reg}, {arg2_reg}")
            instructions.append(f"mflo {result_reg}  # quotient")
        else:
            instructions.append(f"{mips_op} {result_reg}, {arg1_reg}, {arg2_reg}")

        return instructions

    def _translate_assignment_quad(self, quad):
        """
        Traduce cuádruplos de asignación: (=, value, None, target)
        Ejemplo: (=, 5, None, 0x1000) -> li $t0, 5; sw $t0, var_a
        """
        instructions = []

        value = quad.arg1
        target = quad.result

        # Obtener registro para el valor
        value_reg = self.register_allocator.get_reg_temp("assign_temp")

        # Cargar el valor usando el helper
        if self._is_temporary(value):
            # Si es temporal, obtener su registro
            value_reg = self.register_allocator.get_reg(value)
        else:
            # Usar helper para cargar inmediato o variable
            self._load_value_to_reg(value, value_reg, instructions)

        # Guardar en el target
        if self._is_temporary(target):
            # Si target es temporal, mover a su registro
            target_reg = self.register_allocator.get_reg(target)
            if value_reg != target_reg:
                instructions.append(f"move {target_reg}, {value_reg}")
        else:
            # Es una variable o dirección, guardar en memoria
            target_addr = self._get_memory_label(target)
            instructions.append(f"sw {value_reg}, {target_addr}")

        return instructions

    def _translate_load_quad(self, quad):
        """
        Traduce cuádruplos de carga: (@, addr, None, temp)
        Ejemplos:
        - (@, 0x1000, None, t0) -> lw $t0, var_a
        - (@, FP[8], None, t0) -> lw $t0, 8($fp)  # Parameter/local access
        """
        instructions = []

        addr = quad.arg1
        target_temp = quad.result

        # Obtener registro para el temporal
        target_reg = self.register_allocator.get_reg(target_temp)

        # Check if this is FP-relative addressing (parameters/locals)
        if isinstance(addr, str) and addr.startswith('FP[') and addr.endswith(']'):
            # Extract offset from FP[offset]
            offset_str = addr[3:-1]  # Remove "FP[" and "]"
            offset = offset_str
            instructions.append(f"lw {target_reg}, {offset}($fp)  # Load from frame")
        else:
            # Regular memory load
            source_addr = self._get_memory_label(addr)
            instructions.append(f"lw {target_reg}, {source_addr}")

        return instructions

    def _translate_comparison_quad(self, quad):
        """
        Traduce cuádruplos de comparación: (op, arg1, arg2, result)
        Ejemplo: (<, t0, t1, t2) -> slt $t2, $t0, $t1

        En MIPS, las comparaciones usan:
        - slt (set less than): result = 1 si arg1 < arg2, 0 si no
        - seq (set equal): result = 1 si arg1 == arg2, 0 si no
        - sne (set not equal): result = 1 si arg1 != arg2, 0 si no
        - Para <=, >, >= usamos combinaciones
        """
        instructions = []

        # Obtener registros para los operandos
        arg1_reg = self.register_allocator.get_reg(quad.arg1)
        arg2_reg = self.register_allocator.get_reg(quad.arg2)
        result_reg = self.register_allocator.get_reg(quad.result)

        # Cargar arg1
        if self._is_temporary(quad.arg1):
            # Si es temporal, ya debería estar en registro
            pass
        elif self._is_fp_relative(quad.arg1):
            # FP-relative addressing: FP[offset]
            offset = self._extract_fp_offset(quad.arg1)
            instructions.append(f"lw {arg1_reg}, {offset}($fp)  # Load from frame")
        elif self._is_immediate(quad.arg1):
            instructions.append(f"li {arg1_reg}, {quad.arg1}")
        else:
            # Es una variable, cargar desde memoria
            addr = self._get_memory_label(quad.arg1)
            instructions.append(f"lw {arg1_reg}, {addr}")

        # Cargar arg2
        if self._is_temporary(quad.arg2):
            # Si es temporal, ya debería estar en registro
            pass
        elif self._is_fp_relative(quad.arg2):
            # FP-relative addressing: FP[offset]
            offset = self._extract_fp_offset(quad.arg2)
            instructions.append(f"lw {arg2_reg}, {offset}($fp)  # Load from frame")
        elif self._is_immediate(quad.arg2):
            instructions.append(f"li {arg2_reg}, {quad.arg2}")
        else:
            # Es una variable, cargar desde memoria
            addr = self._get_memory_label(quad.arg2)
            instructions.append(f"lw {arg2_reg}, {addr}")

        # Realizar la comparación
        if quad.op == '<':
            # slt: set less than
            instructions.append(f"slt {result_reg}, {arg1_reg}, {arg2_reg}")

        elif quad.op == '<=':
            # <= es equivalente a: NOT (arg1 > arg2)
            # arg1 <= arg2 es lo mismo que arg2 >= arg1
            # Usamos: slt $temp, arg2, arg1; xori result, $temp, 1
            temp_reg = self.register_allocator.get_reg_temp("cmp_temp")
            instructions.append(f"slt {temp_reg}, {arg2_reg}, {arg1_reg}")  # temp = arg2 < arg1
            instructions.append(f"xori {result_reg}, {temp_reg}, 1")  # result = NOT temp

        elif quad.op == '>':
            # > es lo mismo que arg2 < arg1
            instructions.append(f"slt {result_reg}, {arg2_reg}, {arg1_reg}")

        elif quad.op == '>=':
            # >= es equivalente a: NOT (arg1 < arg2)
            temp_reg = self.register_allocator.get_reg_temp("cmp_temp")
            instructions.append(f"slt {temp_reg}, {arg1_reg}, {arg2_reg}")  # temp = arg1 < arg2
            instructions.append(f"xori {result_reg}, {temp_reg}, 1")  # result = NOT temp

        elif quad.op == '==':
            # == : xor + seq (set equal to zero)
            # Si arg1 == arg2, entonces arg1 XOR arg2 = 0
            instructions.append(f"xor {result_reg}, {arg1_reg}, {arg2_reg}")
            instructions.append(f"sltiu {result_reg}, {result_reg}, 1")  # result = (result == 0)

        elif quad.op == '!=':
            # != : xor + sne (set not equal to zero)
            # Si arg1 != arg2, entonces arg1 XOR arg2 != 0
            instructions.append(f"xor {result_reg}, {arg1_reg}, {arg2_reg}")
            instructions.append(f"sltu {result_reg}, $zero, {result_reg}")  # result = (result != 0)

        return instructions

    def _translate_logical_quad(self, quad):
        """
        Traduce operaciones lógicas: &&, ||, !

        Para operaciones lógicas simples (sin cortocircuito en cuádruplos):
        - && : AND bit a bit
        - || : OR bit a bit
        - ! : NOT lógico (invertir booleano)

        Nota: Si el código intermedio ya maneja cortocircuito con labels,
        esas operaciones se traducen como comparaciones + saltos.
        """
        instructions = []

        if quad.op == '!':
            # NOT lógico: (!, operand, None, result)
            # En MIPS: xori result, operand, 1 (invertir bit)
            # O también: seq result, operand, $zero (result = operand == 0)

            operand = quad.arg1
            result = quad.result

            # Obtener registros
            operand_reg = self.register_allocator.get_reg(operand)
            result_reg = self.register_allocator.get_reg(result)

            # Cargar operando usando helper
            if not self._is_temporary(operand):
                self._load_value_to_reg(operand, operand_reg, instructions)

            # NOT lógico: result = (operand == 0) ? 1 : 0
            instructions.append(f"sltiu {result_reg}, {operand_reg}, 1")

        elif quad.op == '&&':
            # AND lógico: (&&, arg1, arg2, result)
            # Nota: Si hay cortocircuito, esto se traduce con labels
            # Aquí implementamos AND simple bit a bit

            arg1 = quad.arg1
            arg2 = quad.arg2
            result = quad.result

            # Obtener registros
            arg1_reg = self.register_allocator.get_reg(arg1)
            arg2_reg = self.register_allocator.get_reg(arg2)
            result_reg = self.register_allocator.get_reg(result)

            # Cargar arg1
            if self._is_temporary(arg1):
                pass
            elif self._is_immediate(arg1):
                instructions.append(f"li {arg1_reg}, {arg1}")
            else:
                addr = self._get_memory_label(arg1)
                instructions.append(f"lw {arg1_reg}, {addr}")

            # Cargar arg2
            if self._is_temporary(arg2):
                pass
            elif self._is_immediate(arg2):
                instructions.append(f"li {arg2_reg}, {arg2}")
            else:
                addr = self._get_memory_label(arg2)
                instructions.append(f"lw {arg2_reg}, {addr}")

            # AND bit a bit
            instructions.append(f"and {result_reg}, {arg1_reg}, {arg2_reg}")
            # Normalizar a booleano (0 o 1)
            instructions.append(f"sltu {result_reg}, $zero, {result_reg}")

        elif quad.op == '||':
            # OR lógico: (||, arg1, arg2, result)

            arg1 = quad.arg1
            arg2 = quad.arg2
            result = quad.result

            # Obtener registros
            arg1_reg = self.register_allocator.get_reg(arg1)
            arg2_reg = self.register_allocator.get_reg(arg2)
            result_reg = self.register_allocator.get_reg(result)

            # Cargar arg1
            if self._is_temporary(arg1):
                pass
            elif self._is_immediate(arg1):
                instructions.append(f"li {arg1_reg}, {arg1}")
            else:
                addr = self._get_memory_label(arg1)
                instructions.append(f"lw {arg1_reg}, {addr}")

            # Cargar arg2
            if self._is_temporary(arg2):
                pass
            elif self._is_immediate(arg2):
                instructions.append(f"li {arg2_reg}, {arg2}")
            else:
                addr = self._get_memory_label(arg2)
                instructions.append(f"lw {arg2_reg}, {addr}")

            # OR bit a bit
            instructions.append(f"or {result_reg}, {arg1_reg}, {arg2_reg}")
            # Normalizar a booleano (0 o 1)
            instructions.append(f"sltu {result_reg}, $zero, {result_reg}")

        return instructions

    def _translate_unary_quad(self, quad):
        """
        Traduce operaciones unarias

        Principalmente la negación aritmética: -x
        Cuádruplo: (-, operand, None, result) o (NEG, operand, None, result)
        """
        instructions = []

        if quad.op in ['-', 'NEG']:
            # Negación aritmética: (-, operand, None, result)
            # En MIPS: sub result, $zero, operand
            # O también: neg result, operand (pseudo-instrucción)

            operand = quad.arg1
            result = quad.result

            # Obtener registros
            operand_reg = self.register_allocator.get_reg(operand)
            result_reg = self.register_allocator.get_reg(result)

            # Cargar operando si es necesario
            if self._is_temporary(operand):
                pass
            elif self._is_immediate(operand):
                instructions.append(f"li {operand_reg}, {operand}")
            else:
                addr = self._get_memory_label(operand)
                instructions.append(f"lw {operand_reg}, {addr}")

            # Negar: result = 0 - operand
            instructions.append(f"sub {result_reg}, $zero, {operand_reg}")

        return instructions

    def _translate_modulo_quad(self, quad):
        """
        Traduce operación de módulo: (%, arg1, arg2, result)

        En MIPS:
        - div arg1, arg2  (divide arg1 / arg2)
        - mfhi result     (obtener resto/módulo)
        """
        instructions = []

        arg1 = quad.arg1
        arg2 = quad.arg2
        result = quad.result

        # Obtener registros
        arg1_reg = self.register_allocator.get_reg(arg1)
        arg2_reg = self.register_allocator.get_reg(arg2)
        result_reg = self.register_allocator.get_reg(result)

        # Cargar arg1
        if self._is_temporary(arg1):
            pass
        elif self._is_immediate(arg1):
            instructions.append(f"li {arg1_reg}, {arg1}")
        else:
            addr = self._get_memory_label(arg1)
            instructions.append(f"lw {arg1_reg}, {addr}")

        # Cargar arg2
        if self._is_temporary(arg2):
            pass
        elif self._is_immediate(arg2):
            instructions.append(f"li {arg2_reg}, {arg2}")
        else:
            addr = self._get_memory_label(arg2)
            instructions.append(f"lw {arg2_reg}, {addr}")

        # División y obtener resto
        instructions.append(f"div {arg1_reg}, {arg2_reg}")
        instructions.append(f"mfhi {result_reg}  # Get remainder (modulo)")

        return instructions

    def _translate_jump_quad(self, quad):
        """
        Traduce cuádruplos de salto y control de flujo

        Tipos de saltos:
        - goto: Salto incondicional
        - if: Salto si la condición es verdadera (!=0)
        - if_false/ifFalse: Salto si la condición es falsa (==0)
        """
        instructions = []

        if quad.op == 'goto':
            # Salto incondicional: (goto, None, None, label)
            label = self._sanitize_label(quad.result)
            instructions.append(f"j {label}")

        elif quad.op in ['if', 'if_true']:
            # Salto condicional si verdadero: (if, condition, None, label)
            # En MIPS: bne condition, $zero, label (branch if not equal to zero)
            condition = quad.arg1
            label = self._sanitize_label(quad.result)

            # Obtener registro de la condición
            cond_reg = self.register_allocator.get_reg(condition)

            # Cargar condición si es necesario
            if self._is_temporary(condition):
                # Ya está en registro
                pass
            elif self._is_immediate(condition):
                instructions.append(f"li {cond_reg}, {condition}")
            else:
                # Es una variable
                addr = self._get_memory_label(condition)
                instructions.append(f"lw {cond_reg}, {addr}")

            # Branch if not equal to zero (si es verdadero)
            instructions.append(f"bne {cond_reg}, $zero, {label}")

        elif quad.op in ['if_false', 'ifFalse']:
            # Salto condicional si falso: (if_false, condition, None, label)
            # En MIPS: beq condition, $zero, label (branch if equal to zero)
            condition = quad.arg1
            label = self._sanitize_label(quad.result)

            # Obtener registro de la condición
            cond_reg = self.register_allocator.get_reg(condition)

            # Cargar condición si es necesario
            if self._is_temporary(condition):
                # Ya está en registro
                pass
            elif self._is_immediate(condition):
                instructions.append(f"li {cond_reg}, {condition}")
            else:
                # Es una variable
                addr = self._get_memory_label(condition)
                instructions.append(f"lw {cond_reg}, {addr}")

            # Branch if equal to zero (si es falso)
            instructions.append(f"beq {cond_reg}, $zero, {label}")

        return instructions

    def _translate_label_quad(self, quad):
        """
        Traduce cuádruplos de etiqueta: (label, None, None, L0)
        Simplemente genera la etiqueta en MIPS
        """
        label_name = self._sanitize_label(quad.result)
        return [f"{label_name}:"]

    def _translate_function_quad(self, quad):
        """
        Traduce cuádruplos de función: enter, call, push, pop, return, leave

        Quadruples:
        - (enter, size, None, None): Function prologue
        - (push, arg, None, None): Push argument for call
        - (call, None, None, func_label): Call function
        - (pop, None, None, result): Get return value
        - (return, value, None, None): Return from function
        - (leave, None, None, None): Function epilogue
        """
        instructions = []

        if quad.op == 'enter':
            # Function prologue: setup stack frame
            # On entry: $sp points to last pushed argument (first parameter)
            # TAC convention: FP[0] = first param, FP[4] = second param, etc.
            # So $fp must point to the first parameter location
            #
            # Stack layout after prologue:
            # [arg2]
            # [arg1]
            # [arg0] ← $fp points here (FP[0])
            # [$ra]  ← -4($fp)
            # [$fp]  ← -8($fp)
            # [locals] ← $sp points here

            frame_size = int(quad.arg1) if quad.arg1 else 0

            instructions.append(f"# Function prologue (locals: {frame_size} bytes)")

            # Save $ra and $fp BELOW current $sp (which points to arg0)
            instructions.append(f"sw $ra, -4($sp)")
            instructions.append(f"sw $fp, -8($sp)")

            # Set $fp to point to arg0 location (current $sp)
            instructions.append(f"move $fp, $sp")

            # Move $sp down past saved $ra/$fp and allocate locals
            total_offset = 8 + frame_size
            instructions.append(f"addiu $sp, $sp, -{total_offset}")

        elif quad.op == 'leave':
            # Function epilogue: cleanup stack frame
            # Current state: $fp points to arg0, $sp points below locals
            # Saved $fp is at -8($fp), saved $ra is at -4($fp)
            instructions.append(f"# Function epilogue")

            # Point $sp to saved $fp location
            instructions.append(f"addiu $sp, $fp, -8")

            # Restore $fp and $ra
            instructions.append(f"lw $fp, 0($sp)")
            instructions.append(f"lw $ra, 4($sp)")

            # Pop $fp/$ra from stack (sp now points to arg0 location)
            instructions.append(f"addiu $sp, $sp, 8")

            # Return to caller (caller will clean up arguments)
            instructions.append(f"jr $ra")

        elif quad.op == 'push':
            # Push argument onto stack for function call
            # Arguments are pushed in reverse order
            arg = quad.arg1

            instructions.append(f"# Push argument: {arg}")

            # Get register for argument
            arg_reg = self.register_allocator.get_reg_temp("push_arg")

            # Load argument value
            if self._is_temporary(arg):
                arg_reg = self.register_allocator.get_reg(arg)
            else:
                self._load_value_to_reg(arg, arg_reg, instructions)

            # Push onto stack
            instructions.append(f"addiu $sp, $sp, -4")
            instructions.append(f"sw {arg_reg}, 0($sp)")

            # Track for parameter passing to $a0-$a3 if needed
            self.param_registers.append(arg_reg)

        elif quad.op == 'call':
            # Call function
            func_label = self._sanitize_label(quad.result)

            instructions.append(f"# Call function: {quad.result}")

            # In MIPS calling convention, first 4 args go in $a0-$a3
            # For simplicity, we're using stack-based passing (already pushed)
            # But we could optimize by using $a0-$a3 for first 4 args

            instructions.append(f"jal {func_label}")

            # Clear param register tracking
            self.param_registers.clear()

        elif quad.op == 'pop':
            # Pop return value from function call
            # Return value is in $v0
            result = quad.result

            instructions.append(f"# Get return value")

            if self._is_temporary(result):
                result_reg = self.register_allocator.get_reg(result)
                instructions.append(f"move {result_reg}, $v0")
            else:
                # Store return value to memory
                result_addr = self._get_memory_label(result)
                instructions.append(f"sw $v0, {result_addr}")

        elif quad.op == 'return':
            # Return from function with optional value
            return_value = quad.arg1

            instructions.append(f"# Return statement")

            if return_value is not None:
                # Load return value into $v0
                if self._is_temporary(return_value):
                    return_reg = self.register_allocator.get_reg(return_value)
                    instructions.append(f"move $v0, {return_reg}")
                else:
                    # Load from memory or immediate
                    temp_reg = self.register_allocator.get_reg_temp("return_temp")
                    self._load_value_to_reg(return_value, temp_reg, instructions)
                    instructions.append(f"move $v0, {temp_reg}")

            # Jump to function epilogue (leave will handle cleanup)
            # For now, we don't jump - leave quadruple follows immediately

        elif quad.op == 'add' and (quad.arg1 == 'SP' or str(quad.arg1).upper() == 'SP'):
            # Stack cleanup after function call: (add, SP, size, SP)
            # This adjusts SP after popping arguments
            cleanup_size = quad.arg2
            instructions.append(f"# Clean up arguments from stack ({cleanup_size} bytes)")
            instructions.append(f"addiu $sp, $sp, {cleanup_size}")

        return instructions

    def _is_temporary(self, value):
        """
        Verifica si un valor es un temporal (t0, t1, etc.)

        NOTA: Debido a un bug en el código intermedio, a veces 'true' o 'false'
        se usan como nombres de temporales. Por ahora, NO los consideramos temporales
        para forzar su conversión a valores numéricos.
        """
        if not isinstance(value, str):
            return False

        # No tratar 'true' o 'false' como temporales, incluso si el código intermedio los usa así
        if value in ['true', 'false']:
            return False

        return value.startswith('t') and value[1:].isdigit()

    def _is_fp_relative(self, value):
        """
        Verifica si un valor es una dirección relativa al frame pointer (FP[offset])
        """
        return isinstance(value, str) and value.startswith('FP[') and value.endswith(']')

    def _extract_fp_offset(self, fp_address):
        """
        Extrae el offset de una dirección FP-relative
        Ejemplo: "FP[8]" -> "8"
        """
        if self._is_fp_relative(fp_address):
            return fp_address[3:-1]  # Remove "FP[" and "]"
        return "0"

    def _sanitize_label(self, label):
        """
        Sanitiza etiquetas para que sean válidas en MIPS
        Convierte espacios y paréntesis a guiones bajos
        Ejemplo: "FUNC_add (Calculator)" -> "FUNC_add_Calculator"
        """
        if not isinstance(label, str):
            return str(label)
        # Replace spaces with underscores
        sanitized = label.replace(' ', '_')
        # Remove parentheses
        sanitized = sanitized.replace('(', '').replace(')', '')
        return sanitized

    def _is_immediate(self, value):
        """Verifica si un valor es un inmediato (número o booleano)"""
        if isinstance(value, (int, float)):
            return True
        if isinstance(value, str):
            # Verificar si es un booleano literal
            if value in ['true', 'false']:
                return True
            try:
                # Use base 0 to auto-detect hex (0x...), octal (0o...), etc.
                int(value, 0)
                return True
            except ValueError:
                return False
        return False

    def _normalize_value(self, value):
        """
        Normaliza un valor, convirtiendo booleanos literales a números

        Args:
            value: El valor a normalizar (puede ser 'true', 'false', número, etc.)

        Returns:
            El valor normalizado (true -> 1, false -> 0, otros sin cambio)
        """
        if isinstance(value, str):
            if value == 'true':
                return '1'
            elif value == 'false':
                return '0'
        return value

    def _load_value_to_reg(self, value, reg, instructions):
        """
        Helper para cargar un valor en un registro, manejando temporales, inmediatos y variables

        Args:
            value: El valor a cargar (puede ser temporal, inmediato, variable, etc.)
            reg: El registro destino
            instructions: Lista de instrucciones donde agregar el código

        Returns:
            None (modifica instructions in-place)
        """
        if self._is_temporary(value):
            # Si es temporal, ya está en registro (no hacer nada)
            pass
        elif self._is_fp_relative(value):
            # FP-relative addressing: FP[offset]
            offset = self._extract_fp_offset(value)
            instructions.append(f"lw {reg}, {offset}($fp)  # Load from frame")
        elif self._is_immediate(value):
            # Es un inmediato (número o booleano)
            normalized = self._normalize_value(value)
            instructions.append(f"li {reg}, {normalized}")
        else:
            # Es una variable, cargar desde memoria
            addr = self._get_memory_label(value)
            instructions.append(f"lw {reg}, {addr}")

    def _get_memory_label(self, identifier):
        """
        Obtiene la etiqueta de memoria para un identificador

        Args:
            identifier: Puede ser un nombre de variable o una dirección hexadecimal

        Returns:
            String con la etiqueta MIPS (ej: "var_a" o "0x1000")
        """
        # Si es una dirección hexadecimal
        if isinstance(identifier, str) and identifier.startswith('0x'):
            # Buscar la variable correspondiente
            try:
                addr = int(identifier, 16)
                for var_name, var_addr in self.memory_manager.allocations.items():
                    if var_addr == addr:
                        return f"var_{var_name}"
                # Si no se encuentra, usar la dirección directamente
                return identifier
            except ValueError:
                pass

        # Si es un nombre de variable
        if identifier in self.memory_manager.allocations:
            return f"var_{identifier}"

        # Si no se encuentra, asumir que es una etiqueta válida
        return str(identifier)

    def _assemble_final_code(self):
        """Ensambla todas las secciones en un programa MIPS completo"""
        lines = []

        # Encabezado
        lines.append("# Generated by Compiscript Compiler")
        lines.append("# MIPS Assembly Code")
        lines.append("")

        # Sección de datos
        lines.extend(self.data_section)
        lines.append("")

        # Sección de texto
        lines.extend(self.text_section)
        lines.append("")

        # Funciones de runtime (futuro)
        # lines.extend(self.runtime.get_runtime_functions())

        return "\n".join(lines)

    def save_to_file(self, filename):
        """Guarda el código MIPS en un archivo .asm"""
        code = self.generate_mips_code()
        with open(filename, 'w') as f:
            f.write(code)
        return filename
